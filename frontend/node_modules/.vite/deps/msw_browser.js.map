{
  "version": 3,
  "sources": ["../../msw/src/core/utils/internal/mergeRight.ts", "../../msw/src/core/utils/toResponseInit.ts", "../../msw/src/core/utils/internal/isHandlerKind.ts", "../../@mswjs/interceptors/src/utils/emitAsync.ts", "../../@mswjs/interceptors/src/utils/hasConfigurableGlobal.ts", "../../@mswjs/interceptors/src/interceptors/WebSocket/utils/bindEvent.ts", "../../@mswjs/interceptors/src/interceptors/WebSocket/utils/events.ts", "../../@mswjs/interceptors/src/interceptors/WebSocket/WebSocketClientConnection.ts", "../../@mswjs/interceptors/src/interceptors/WebSocket/WebSocketOverride.ts", "../../@mswjs/interceptors/src/interceptors/WebSocket/WebSocketServerConnection.ts", "../../@mswjs/interceptors/src/interceptors/WebSocket/WebSocketClassTransport.ts", "../../@mswjs/interceptors/src/interceptors/WebSocket/index.ts", "../../msw/src/core/ws/webSocketInterceptor.ts", "../../msw/src/core/ws/handleWebSocketEvent.ts", "../../msw/node_modules/.pnpm/outvariant@1.4.3/node_modules/outvariant/src/format.ts", "../../msw/node_modules/.pnpm/outvariant@1.4.3/node_modules/outvariant/src/invariant.ts", "../../msw/node_modules/.pnpm/is-node-process@1.2.0/node_modules/is-node-process/src/index.ts", "../../msw/node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/src/createDeferredExecutor.ts", "../../msw/node_modules/.pnpm/@open-draft+deferred-promise@2.2.0/node_modules/@open-draft/deferred-promise/src/DeferredPromise.ts", "../../msw/src/browser/setupWorker/start/utils/prepareStartHandler.ts", "../../msw/src/browser/setupWorker/start/createStartHandler.ts", "../../msw/node_modules/.pnpm/until-async@3.0.2/node_modules/until-async/src/index.ts", "../../msw/src/browser/setupWorker/start/utils/getWorkerInstance.ts", "../../msw/src/browser/utils/getAbsoluteWorkerUrl.ts", "../../msw/src/browser/setupWorker/start/utils/getWorkerByRegistration.ts", "../../msw/src/browser/setupWorker/start/utils/printStartMessage.ts", "../../msw/src/browser/setupWorker/start/utils/enableMocking.ts", "../../msw/src/browser/utils/pruneGetRequestBody.ts", "../../msw/src/browser/utils/deserializeRequest.ts", "../../msw/src/browser/utils/supports.ts", "../../msw/src/browser/setupWorker/start/createRequestListener.ts", "../../msw/src/browser/utils/checkWorkerIntegrity.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/glossary.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/InterceptorError.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/RequestController.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/canParseUrl.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/getValueBySymbol.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/fetchUtils.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/getRawRequest.ts", "../../msw/node_modules/.pnpm/@open-draft+logger@0.3.0/node_modules/@open-draft/logger/lib/index.mjs", "../../msw/node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/src/MemoryLeakError.ts", "../../msw/node_modules/.pnpm/strict-event-emitter@0.5.1/node_modules/strict-event-emitter/src/Emitter.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/Interceptor.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/createRequestId.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/bufferUtils.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/BatchInterceptor.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/getCleanUrl.ts", "../../msw/src/browser/setupWorker/start/createResponseListener.ts", "../../msw/src/browser/setupWorker/start/utils/validateWorkerScope.ts", "../../msw/src/browser/setupWorker/setupWorker.ts", "../../msw/node_modules/.pnpm/rettime@0.10.1/node_modules/rettime/src/lens-list.ts", "../../msw/node_modules/.pnpm/rettime@0.10.1/node_modules/rettime/src/index.ts", "../../msw/src/browser/utils/workerChannel.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/emitAsync.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/hasConfigurableGlobal.ts", "../../msw/node_modules/.pnpm/@open-draft+until@2.1.0/node_modules/@open-draft/until/src/until.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/isObject.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/isPropertyAccessible.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/responseUtils.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/isNodeLikeError.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/handleRequest.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/fetch/utils/createNetworkError.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/fetch/utils/followRedirect.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/fetch/utils/brotli-decompress.browser.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/fetch/utils/decompression.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/fetch/index.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/concatArrayBuffer.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/polyfills/EventPolyfill.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/polyfills/ProgressEventPolyfill.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/createEvent.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/findPropertySource.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/createProxy.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/isDomParserSupportedType.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/utils/parseJson.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/createResponse.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/utils/getBodyByteLength.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/XMLHttpRequestController.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/XMLHttpRequestProxy.ts", "../../msw/node_modules/.pnpm/@mswjs+interceptors@0.41.2/node_modules/@mswjs/interceptors/src/interceptors/XMLHttpRequest/index.ts", "../../msw/src/browser/setupWorker/start/createFallbackRequestListener.ts", "../../msw/src/browser/setupWorker/stop/utils/printStopMessage.ts"],
  "sourcesContent": ["import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce(\n    (result, [key, rightValue]) => {\n      const leftValue = result[key]\n\n      if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n        result[key] = leftValue.concat(rightValue)\n        return result\n      }\n\n      if (isObject(leftValue) && isObject(rightValue)) {\n        result[key] = mergeRight(leftValue, rightValue)\n        return result\n      }\n\n      result[key] = rightValue\n      return result\n    },\n    Object.assign({}, left),\n  )\n}\n", "export function toResponseInit(response: Response): ResponseInit {\n  return {\n    status: response.status,\n    statusText: response.statusText,\n    headers: Object.fromEntries(response.headers.entries()),\n  }\n}\n", "import type { HandlerKind } from '../../handlers/common'\nimport type { RequestHandler } from '../../handlers/RequestHandler'\nimport type { WebSocketHandler } from '../../handlers/WebSocketHandler'\n\n/**\n * A filter function that ensures that the provided argument\n * is a handler of the given kind. This helps differentiate\n * between different kinds of handlers, e.g. request and event handlers.\n */\nexport function isHandlerKind<K extends HandlerKind>(kind: K) {\n  return (\n    input: unknown,\n  ): input is K extends 'EventHandler' ? WebSocketHandler : RequestHandler => {\n    return (\n      input != null &&\n      typeof input === 'object' &&\n      '__kind' in input &&\n      input.__kind === kind\n    )\n  }\n}\n", "import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Emits an event on the given emitter but executes\n * the listeners sequentially. This accounts for asynchronous\n * listeners (e.g. those having \"sleep\" and handling the request).\n */\nexport async function emitAsync<\n  Events extends EventMap,\n  EventName extends keyof Events\n>(\n  emitter: Emitter<Events>,\n  eventName: EventName,\n  ...data: Events[EventName]\n): Promise<void> {\n  const listeners = emitter.listeners(eventName)\n\n  if (listeners.length === 0) {\n    return\n  }\n\n  for (const listener of listeners) {\n    await listener.apply(emitter, data)\n  }\n}\n", "/**\n * Returns a boolean indicating whether the given global property\n * is defined and is configurable.\n */\nexport function hasConfigurableGlobal(propertyName: string): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(globalThis, propertyName)\n\n  // The property is not set at all.\n  if (typeof descriptor === 'undefined') {\n    return false\n  }\n\n  // The property is set to a getter that returns undefined.\n  if (\n    typeof descriptor.get === 'function' &&\n    typeof descriptor.get() === 'undefined'\n  ) {\n    return false\n  }\n\n  // The property is set to a value equal to undefined.\n  if (typeof descriptor.get === 'undefined' && descriptor.value == null) {\n    return false\n  }\n\n  if (typeof descriptor.set === 'undefined' && !descriptor.configurable) {\n    console.error(\n      `[MSW] Failed to apply interceptor: the global \\`${propertyName}\\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`\n    )\n    return false\n  }\n\n  return true\n}\n", "type EventWithTarget<E extends Event, T> = E & { target: T }\n\nexport function bindEvent<E extends Event, T>(\n  target: T,\n  event: E\n): EventWithTarget<E, T> {\n  Object.defineProperties(event, {\n    target: {\n      value: target,\n      enumerable: true,\n      writable: true,\n    },\n    currentTarget: {\n      value: target,\n      enumerable: true,\n      writable: true,\n    },\n  })\n\n  return event as EventWithTarget<E, T>\n}\n", "const kCancelable = Symbol('kCancelable')\nconst kDefaultPrevented = Symbol('kDefaultPrevented')\n\n/**\n * A `MessageEvent` superset that supports event cancellation\n * in Node.js. It's rather non-intrusive so it can be safely\n * used in the browser as well.\n *\n * @see https://github.com/nodejs/node/issues/51767\n */\nexport class CancelableMessageEvent<T = any> extends MessageEvent<T> {\n  [kCancelable]: boolean;\n  [kDefaultPrevented]: boolean\n\n  constructor(type: string, init: MessageEventInit<T>) {\n    super(type, init)\n    this[kCancelable] = !!init.cancelable\n    this[kDefaultPrevented] = false\n  }\n\n  get cancelable() {\n    return this[kCancelable]\n  }\n\n  set cancelable(nextCancelable) {\n    this[kCancelable] = nextCancelable\n  }\n\n  get defaultPrevented() {\n    return this[kDefaultPrevented]\n  }\n\n  set defaultPrevented(nextDefaultPrevented) {\n    this[kDefaultPrevented] = nextDefaultPrevented\n  }\n\n  public preventDefault(): void {\n    if (this.cancelable && !this[kDefaultPrevented]) {\n      this[kDefaultPrevented] = true\n    }\n  }\n}\n\ninterface CloseEventInit extends EventInit {\n  code?: number\n  reason?: string\n  wasClean?: boolean\n}\n\nexport class CloseEvent extends Event {\n  public code: number\n  public reason: string\n  public wasClean: boolean\n\n  constructor(type: string, init: CloseEventInit = {}) {\n    super(type, init)\n    this.code = init.code === undefined ? 0 : init.code\n    this.reason = init.reason === undefined ? '' : init.reason\n    this.wasClean = init.wasClean === undefined ? false : init.wasClean\n  }\n}\n\nexport class CancelableCloseEvent extends CloseEvent {\n  [kCancelable]: boolean;\n  [kDefaultPrevented]: boolean\n\n  constructor(type: string, init: CloseEventInit = {}) {\n    super(type, init)\n    this[kCancelable] = !!init.cancelable\n    this[kDefaultPrevented] = false\n  }\n\n  get cancelable() {\n    return this[kCancelable]\n  }\n\n  set cancelable(nextCancelable) {\n    this[kCancelable] = nextCancelable\n  }\n\n  get defaultPrevented() {\n    return this[kDefaultPrevented]\n  }\n\n  set defaultPrevented(nextDefaultPrevented) {\n    this[kDefaultPrevented] = nextDefaultPrevented\n  }\n\n  public preventDefault(): void {\n    if (this.cancelable && !this[kDefaultPrevented]) {\n      this[kDefaultPrevented] = true\n    }\n  }\n}\n", "import type { WebSocketData, WebSocketTransport } from './WebSocketTransport'\nimport type { WebSocketEventListener } from './WebSocketOverride'\nimport { bindEvent } from './utils/bindEvent'\nimport { CancelableMessageEvent, CloseEvent } from './utils/events'\nimport { createRequestId } from '../../createRequestId'\n\nconst kEmitter = Symbol('kEmitter')\nconst kBoundListener = Symbol('kBoundListener')\n\nexport interface WebSocketClientEventMap {\n  message: MessageEvent<WebSocketData>\n  close: CloseEvent\n}\n\nexport abstract class WebSocketClientConnectionProtocol {\n  abstract id: string\n  abstract url: URL\n  public abstract send(data: WebSocketData): void\n  public abstract close(code?: number, reason?: string): void\n\n  public abstract addEventListener<\n    EventType extends keyof WebSocketClientEventMap,\n  >(\n    type: EventType,\n    listener: WebSocketEventListener<WebSocketClientEventMap[EventType]>,\n    options?: AddEventListenerOptions | boolean\n  ): void\n\n  public abstract removeEventListener<\n    EventType extends keyof WebSocketClientEventMap,\n  >(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketClientEventMap[EventType]>,\n    options?: EventListenerOptions | boolean\n  ): void\n}\n\n/**\n * The WebSocket client instance represents an incoming\n * client connection. The user can control the connection,\n * send and receive events.\n */\nexport class WebSocketClientConnection implements WebSocketClientConnectionProtocol {\n  public readonly id: string\n  public readonly url: URL\n\n  private [kEmitter]: EventTarget\n\n  constructor(\n    public readonly socket: WebSocket,\n    private readonly transport: WebSocketTransport\n  ) {\n    this.id = createRequestId()\n    this.url = new URL(socket.url)\n    this[kEmitter] = new EventTarget()\n\n    // Emit outgoing client data (\"ws.send()\") as \"message\"\n    // events on the \"client\" connection.\n    this.transport.addEventListener('outgoing', (event) => {\n      const message = bindEvent(\n        this.socket,\n        new CancelableMessageEvent('message', {\n          data: event.data,\n          origin: event.origin,\n          cancelable: true,\n        })\n      )\n\n      this[kEmitter].dispatchEvent(message)\n\n      // This is a bit silly but forward the cancellation state\n      // of the \"client\" message event to the \"outgoing\" transport event.\n      // This way, other agens (like \"server\" connection) can know\n      // whether the client listener has pervented the default.\n      if (message.defaultPrevented) {\n        event.preventDefault()\n      }\n    })\n\n    /**\n     * Emit the \"close\" event on the \"client\" connection\n     * whenever the underlying transport is closed.\n     * @note \"client.close()\" does NOT dispatch the \"close\"\n     * event on the WebSocket because it uses non-configurable\n     * close status code. Thus, we listen to the transport\n     * instead of the WebSocket's \"close\" event.\n     */\n    this.transport.addEventListener('close', (event) => {\n      this[kEmitter].dispatchEvent(\n        bindEvent(this.socket, new CloseEvent('close', event))\n      )\n    })\n  }\n\n  /**\n   * Listen for the outgoing events from the connected WebSocket client.\n   */\n  public addEventListener<EventType extends keyof WebSocketClientEventMap>(\n    type: EventType,\n    listener: WebSocketEventListener<WebSocketClientEventMap[EventType]>,\n    options?: AddEventListenerOptions | boolean\n  ): void {\n    if (!Reflect.has(listener, kBoundListener)) {\n      const boundListener = listener.bind(this.socket)\n\n      // Store the bound listener on the original listener\n      // so the exact bound function can be accessed in \"removeEventListener()\".\n      Object.defineProperty(listener, kBoundListener, {\n        value: boundListener,\n        enumerable: false,\n        configurable: false,\n      })\n    }\n\n    this[kEmitter].addEventListener(\n      type,\n      Reflect.get(listener, kBoundListener) as EventListener,\n      options\n    )\n  }\n\n  /**\n   * Removes the listener for the given event.\n   */\n  public removeEventListener<EventType extends keyof WebSocketClientEventMap>(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketClientEventMap[EventType]>,\n    options?: EventListenerOptions | boolean\n  ): void {\n    this[kEmitter].removeEventListener(\n      event,\n      Reflect.get(listener, kBoundListener) as EventListener,\n      options\n    )\n  }\n\n  /**\n   * Send data to the connected client.\n   */\n  public send(data: WebSocketData): void {\n    this.transport.send(data)\n  }\n\n  /**\n   * Close the WebSocket connection.\n   * @param {number} code A status code (see https://www.rfc-editor.org/rfc/rfc6455#section-7.4.1).\n   * @param {string} reason A custom connection close reason.\n   */\n  public close(code?: number, reason?: string): void {\n    this.transport.close(code, reason)\n  }\n}\n", "import { invariant } from 'outvariant'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport type { WebSocketData } from './WebSocketTransport'\nimport { bindEvent } from './utils/bindEvent'\nimport { CloseEvent } from './utils/events'\nimport { resolveWebSocketUrl } from '../../utils/resolveWebSocketUrl'\n\nexport type WebSocketEventListener<\n  EventType extends WebSocketEventMap[keyof WebSocketEventMap] = Event,\n> = (this: WebSocket, event: EventType) => void\n\nconst WEBSOCKET_CLOSE_CODE_RANGE_ERROR =\n  'InvalidAccessError: close code out of user configurable range'\n\nexport const kPassthroughPromise = Symbol('kPassthroughPromise')\nexport const kOnSend = Symbol('kOnSend')\nexport const kClose = Symbol('kClose')\n\nexport class WebSocketOverride extends EventTarget implements WebSocket {\n  static readonly CONNECTING = 0\n  static readonly OPEN = 1\n  static readonly CLOSING = 2\n  static readonly CLOSED = 3\n  readonly CONNECTING = 0\n  readonly OPEN = 1\n  readonly CLOSING = 2\n  readonly CLOSED = 3\n\n  public url: string\n  public protocol: string\n  public extensions: string\n  public binaryType: BinaryType\n  public readyState: number\n  public bufferedAmount: number\n\n  private _onopen: WebSocketEventListener | null = null\n  private _onmessage: WebSocketEventListener<\n    MessageEvent<WebSocketData>\n  > | null = null\n  private _onerror: WebSocketEventListener | null = null\n  private _onclose: WebSocketEventListener<CloseEvent> | null = null\n\n  private [kPassthroughPromise]: DeferredPromise<boolean>\n  private [kOnSend]?: (data: WebSocketData) => void\n\n  constructor(url: string | URL, protocols?: string | Array<string>) {\n    super()\n    this.url = resolveWebSocketUrl(url)\n    this.protocol = ''\n    this.extensions = ''\n    this.binaryType = 'blob'\n    this.readyState = this.CONNECTING\n    this.bufferedAmount = 0\n\n    this[kPassthroughPromise] = new DeferredPromise<boolean>()\n\n    queueMicrotask(async () => {\n      if (await this[kPassthroughPromise]) {\n        return\n      }\n\n      this.protocol =\n        typeof protocols === 'string'\n          ? protocols\n          : Array.isArray(protocols) && protocols.length > 0\n            ? protocols[0]\n            : ''\n\n      /**\n       * @note Check that nothing has prevented this connection\n       * (e.g. called `client.close()` in the connection listener).\n       * If the connection has been prevented, never dispatch the open event,.\n       */\n      if (this.readyState === this.CONNECTING) {\n        this.readyState = this.OPEN\n        this.dispatchEvent(bindEvent(this, new Event('open')))\n      }\n    })\n  }\n\n  set onopen(listener: WebSocketEventListener | null) {\n    this.removeEventListener('open', this._onopen)\n    this._onopen = listener\n    if (listener !== null) {\n      this.addEventListener('open', listener)\n    }\n  }\n  get onopen(): WebSocketEventListener | null {\n    return this._onopen\n  }\n\n  set onmessage(\n    listener: WebSocketEventListener<MessageEvent<WebSocketData>> | null\n  ) {\n    this.removeEventListener(\n      'message',\n      this._onmessage as WebSocketEventListener\n    )\n    this._onmessage = listener\n    if (listener !== null) {\n      this.addEventListener('message', listener)\n    }\n  }\n  get onmessage(): WebSocketEventListener<MessageEvent<WebSocketData>> | null {\n    return this._onmessage\n  }\n\n  set onerror(listener: WebSocketEventListener | null) {\n    this.removeEventListener('error', this._onerror)\n    this._onerror = listener\n    if (listener !== null) {\n      this.addEventListener('error', listener)\n    }\n  }\n  get onerror(): WebSocketEventListener | null {\n    return this._onerror\n  }\n\n  set onclose(listener: WebSocketEventListener<CloseEvent> | null) {\n    this.removeEventListener('close', this._onclose as WebSocketEventListener)\n    this._onclose = listener\n    if (listener !== null) {\n      this.addEventListener('close', listener)\n    }\n  }\n  get onclose(): WebSocketEventListener<CloseEvent> | null {\n    return this._onclose\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#ref-for-dom-websocket-send%E2%91%A0\n   */\n  public send(data: WebSocketData): void {\n    if (this.readyState === this.CONNECTING) {\n      this.close()\n      throw new DOMException('InvalidStateError')\n    }\n\n    // Sending when the socket is about to close\n    // discards the sent data.\n    if (this.readyState === this.CLOSING || this.readyState === this.CLOSED) {\n      return\n    }\n\n    // Buffer the data to send in this even loop\n    // but send it in the next.\n    this.bufferedAmount += getDataSize(data)\n\n    queueMicrotask(() => {\n      // This is a bit optimistic but since no actual data transfer\n      // is involved, all the data will be \"sent\" on the next tick.\n      this.bufferedAmount = 0\n\n      /**\n       * @note Notify the parent about outgoing data.\n       * This notifies the transport and the connection\n       * listens to the outgoing data to emit the \"message\" event.\n       */\n      this[kOnSend]?.(data)\n    })\n  }\n\n  public close(code: number = 1000, reason?: string): void {\n    invariant(code, WEBSOCKET_CLOSE_CODE_RANGE_ERROR)\n    invariant(\n      code === 1000 || (code >= 3000 && code <= 4999),\n      WEBSOCKET_CLOSE_CODE_RANGE_ERROR\n    )\n\n    this[kClose](code, reason)\n  }\n\n  private [kClose](\n    code: number = 1000,\n    reason?: string,\n    wasClean = true\n  ): void {\n    /**\n     * @note Move this check here so that even internal closures,\n     * like those triggered by the `server` connection, are not\n     * performed twice.\n     */\n    if (this.readyState === this.CLOSING || this.readyState === this.CLOSED) {\n      return\n    }\n\n    this.readyState = this.CLOSING\n\n    queueMicrotask(() => {\n      this.readyState = this.CLOSED\n\n      this.dispatchEvent(\n        bindEvent(\n          this,\n          new CloseEvent('close', {\n            code,\n            reason,\n            wasClean,\n          })\n        )\n      )\n\n      // Remove all event listeners once the socket is closed.\n      this._onopen = null\n      this._onmessage = null\n      this._onerror = null\n      this._onclose = null\n    })\n  }\n\n  public addEventListener<K extends keyof WebSocketEventMap>(\n    type: K,\n    listener: (this: WebSocket, event: WebSocketEventMap[K]) => void,\n    options?: boolean | AddEventListenerOptions\n  ): void\n  public addEventListener(\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  ): void\n  public addEventListener(\n    type: unknown,\n    listener: unknown,\n    options?: unknown\n  ): void {\n    return super.addEventListener(\n      type as string,\n      listener as EventListener,\n      options as AddEventListenerOptions\n    )\n  }\n\n  removeEventListener<K extends keyof WebSocketEventMap>(\n    type: K,\n    callback: EventListenerOrEventListenerObject | null,\n    options?: boolean | EventListenerOptions\n  ): void {\n    return super.removeEventListener(type, callback, options)\n  }\n}\n\nfunction getDataSize(data: WebSocketData): number {\n  if (typeof data === 'string') {\n    return data.length\n  }\n\n  if (data instanceof Blob) {\n    return data.size\n  }\n\n  return data.byteLength\n}\n", "import { invariant } from 'outvariant'\nimport {\n  kClose,\n  WebSocketEventListener,\n  WebSocketOverride,\n} from './WebSocketOverride'\nimport type { WebSocketData } from './WebSocketTransport'\nimport type { WebSocketClassTransport } from './WebSocketClassTransport'\nimport { bindEvent } from './utils/bindEvent'\nimport {\n  CancelableMessageEvent,\n  CancelableCloseEvent,\n  CloseEvent,\n} from './utils/events'\n\nconst kEmitter = Symbol('kEmitter')\nconst kBoundListener = Symbol('kBoundListener')\nconst kSend = Symbol('kSend')\n\nexport interface WebSocketServerEventMap {\n  open: Event\n  message: MessageEvent<WebSocketData>\n  error: Event\n  close: CloseEvent\n}\n\nexport abstract class WebSocketServerConnectionProtocol {\n  public abstract connect(): void\n  public abstract send(data: WebSocketData): void\n  public abstract close(): void\n\n  public abstract addEventListener<\n    EventType extends keyof WebSocketServerEventMap,\n  >(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketServerEventMap[EventType]>,\n    options?: AddEventListenerOptions | boolean\n  ): void\n\n  public abstract removeEventListener<\n    EventType extends keyof WebSocketServerEventMap,\n  >(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketServerEventMap[EventType]>,\n    options?: EventListenerOptions | boolean\n  ): void\n}\n\n/**\n * The WebSocket server instance represents the actual production\n * WebSocket server connection. It's idle by default but you can\n * establish it by calling `server.connect()`.\n */\nexport class WebSocketServerConnection implements WebSocketServerConnectionProtocol {\n  /**\n   * A WebSocket instance connected to the original server.\n   */\n  private realWebSocket?: WebSocket\n  private mockCloseController: AbortController\n  private realCloseController: AbortController\n  private [kEmitter]: EventTarget\n\n  constructor(\n    private readonly client: WebSocketOverride,\n    private readonly transport: WebSocketClassTransport,\n    private readonly createConnection: () => WebSocket\n  ) {\n    this[kEmitter] = new EventTarget()\n    this.mockCloseController = new AbortController()\n    this.realCloseController = new AbortController()\n\n    // Automatically forward outgoing client events\n    // to the actual server unless the outgoing message event\n    // has been prevented. The \"outgoing\" transport event it\n    // dispatched by the \"client\" connection.\n    this.transport.addEventListener('outgoing', (event) => {\n      // Ignore client messages if the server connection\n      // hasn't been established yet. Nowhere to forward.\n      if (typeof this.realWebSocket === 'undefined') {\n        return\n      }\n\n      // Every outgoing client message can prevent this forwarding\n      // by preventing the default of the outgoing message event.\n      // This listener will be added before user-defined listeners,\n      // so execute the logic on the next tick.\n      queueMicrotask(() => {\n        if (!event.defaultPrevented) {\n          /**\n           * @note Use the internal send mechanism so consumers can tell\n           * apart direct user calls to `server.send()` and internal calls.\n           * E.g. MSW has to ignore this internal call to log out messages correctly.\n           */\n          this[kSend](event.data)\n        }\n      })\n    })\n\n    this.transport.addEventListener(\n      'incoming',\n      this.handleIncomingMessage.bind(this)\n    )\n  }\n\n  /**\n   * The `WebSocket` instance connected to the original server.\n   * Accessing this before calling `server.connect()` will throw.\n   */\n  public get socket(): WebSocket {\n    invariant(\n      this.realWebSocket,\n      'Cannot access \"socket\" on the original WebSocket server object: the connection is not open. Did you forget to call `server.connect()`?'\n    )\n\n    return this.realWebSocket\n  }\n\n  /**\n   * Open connection to the original WebSocket server.\n   */\n  public connect(): void {\n    invariant(\n      !this.realWebSocket || this.realWebSocket.readyState !== WebSocket.OPEN,\n      'Failed to call \"connect()\" on the original WebSocket instance: the connection already open'\n    )\n\n    const realWebSocket = this.createConnection()\n\n    // Inherit the binary type from the mock WebSocket client.\n    realWebSocket.binaryType = this.client.binaryType\n\n    // Allow the interceptor to listen to when the server connection\n    // has been established. This isn't necessary to operate with the connection\n    // but may be beneficial in some cases (like conditionally adding logging).\n    realWebSocket.addEventListener(\n      'open',\n      (event) => {\n        this[kEmitter].dispatchEvent(\n          bindEvent(this.realWebSocket!, new Event('open', event))\n        )\n      },\n      { once: true }\n    )\n\n    realWebSocket.addEventListener('message', (event) => {\n      // Dispatch the \"incoming\" transport event instead of\n      // invoking the internal handler directly. This way,\n      // anyone can listen to the \"incoming\" event but this\n      // class is the one resulting in it.\n      this.transport.dispatchEvent(\n        bindEvent(\n          this.realWebSocket!,\n          new MessageEvent('incoming', {\n            data: event.data,\n            origin: event.origin,\n          })\n        )\n      )\n    })\n\n    // Close the original connection when the mock client closes.\n    // E.g. \"client.close()\" was called. This is never forwarded anywhere.\n    this.client.addEventListener(\n      'close',\n      (event) => {\n        this.handleMockClose(event)\n      },\n      {\n        signal: this.mockCloseController.signal,\n      }\n    )\n\n    // Forward the \"close\" event to let the interceptor handle\n    // closures initiated by the original server.\n    realWebSocket.addEventListener(\n      'close',\n      (event) => {\n        this.handleRealClose(event)\n      },\n      {\n        signal: this.realCloseController.signal,\n      }\n    )\n\n    realWebSocket.addEventListener('error', () => {\n      const errorEvent = bindEvent(\n        realWebSocket,\n        new Event('error', { cancelable: true })\n      )\n\n      // Emit the \"error\" event on the `server` connection\n      // to let the interceptor react to original server errors.\n      this[kEmitter].dispatchEvent(errorEvent)\n\n      // If the error event from the original server hasn't been prevented,\n      // forward it to the underlying client.\n      if (!errorEvent.defaultPrevented) {\n        this.client.dispatchEvent(bindEvent(this.client, new Event('error')))\n      }\n    })\n\n    this.realWebSocket = realWebSocket\n  }\n\n  /**\n   * Listen for the incoming events from the original WebSocket server.\n   */\n  public addEventListener<EventType extends keyof WebSocketServerEventMap>(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketServerEventMap[EventType]>,\n    options?: AddEventListenerOptions | boolean\n  ): void {\n    if (!Reflect.has(listener, kBoundListener)) {\n      const boundListener = listener.bind(this.client)\n\n      // Store the bound listener on the original listener\n      // so the exact bound function can be accessed in \"removeEventListener()\".\n      Object.defineProperty(listener, kBoundListener, {\n        value: boundListener,\n        enumerable: false,\n      })\n    }\n\n    this[kEmitter].addEventListener(\n      event,\n      Reflect.get(listener, kBoundListener) as EventListener,\n      options\n    )\n  }\n\n  /**\n   * Remove the listener for the given event.\n   */\n  public removeEventListener<EventType extends keyof WebSocketServerEventMap>(\n    event: EventType,\n    listener: WebSocketEventListener<WebSocketServerEventMap[EventType]>,\n    options?: EventListenerOptions | boolean\n  ): void {\n    this[kEmitter].removeEventListener(\n      event,\n      Reflect.get(listener, kBoundListener) as EventListener,\n      options\n    )\n  }\n\n  /**\n   * Send data to the original WebSocket server.\n   * @example\n   * server.send('hello')\n   * server.send(new Blob(['hello']))\n   * server.send(new TextEncoder().encode('hello'))\n   */\n  public send(data: WebSocketData): void {\n    this[kSend](data)\n  }\n\n  private [kSend](data: WebSocketData): void {\n    const { realWebSocket } = this\n\n    invariant(\n      realWebSocket,\n      'Failed to call \"server.send()\" for \"%s\": the connection is not open. Did you forget to call \"server.connect()\"?',\n      this.client.url\n    )\n\n    // Silently ignore writes on the closed original WebSocket.\n    if (\n      realWebSocket.readyState === WebSocket.CLOSING ||\n      realWebSocket.readyState === WebSocket.CLOSED\n    ) {\n      return\n    }\n\n    // Delegate the send to when the original connection is open.\n    // Unlike the mock, connecting to the original server may take time\n    // so we cannot call this on the next tick.\n    if (realWebSocket.readyState === WebSocket.CONNECTING) {\n      realWebSocket.addEventListener(\n        'open',\n        () => {\n          realWebSocket.send(data)\n        },\n        { once: true }\n      )\n      return\n    }\n\n    // Send the data to the original WebSocket server.\n    realWebSocket.send(data)\n  }\n\n  /**\n   * Close the actual server connection.\n   */\n  public close(): void {\n    const { realWebSocket } = this\n\n    invariant(\n      realWebSocket,\n      'Failed to close server connection for \"%s\": the connection is not open. Did you forget to call \"server.connect()\"?',\n      this.client.url\n    )\n\n    // Remove the \"close\" event listener from the server\n    // so it doesn't close the underlying WebSocket client\n    // when you call \"server.close()\". This also prevents the\n    // `close` event on the `server` connection from being dispatched twice.\n    this.realCloseController.abort()\n\n    if (\n      realWebSocket.readyState === WebSocket.CLOSING ||\n      realWebSocket.readyState === WebSocket.CLOSED\n    ) {\n      return\n    }\n\n    // Close the actual client connection.\n    realWebSocket.close()\n\n    // Dispatch the \"close\" event on the `server` connection.\n    queueMicrotask(() => {\n      this[kEmitter].dispatchEvent(\n        bindEvent(\n          this.realWebSocket,\n          new CancelableCloseEvent('close', {\n            /**\n             * @note `server.close()` in the interceptor\n             * always results in clean closures.\n             */\n            code: 1000,\n            cancelable: true,\n          })\n        )\n      )\n    })\n  }\n\n  private handleIncomingMessage(event: MessageEvent<WebSocketData>): void {\n    // Clone the event to dispatch it on this class\n    // once again and prevent the \"already being dispatched\"\n    // exception. Clone it here so we can observe this event\n    // being prevented in the \"server.on()\" listeners.\n    const messageEvent = bindEvent(\n      event.target,\n      new CancelableMessageEvent('message', {\n        data: event.data,\n        origin: event.origin,\n        cancelable: true,\n      })\n    )\n\n    /**\n     * @note Emit \"message\" event on the server connection\n     * instance to let the interceptor know about these\n     * incoming events from the original server. In that listener,\n     * the interceptor can modify or skip the event forwarding\n     * to the mock WebSocket instance.\n     */\n    this[kEmitter].dispatchEvent(messageEvent)\n\n    /**\n     * @note Forward the incoming server events to the client.\n     * Preventing the default on the message event stops this.\n     */\n    if (!messageEvent.defaultPrevented) {\n      this.client.dispatchEvent(\n        bindEvent(\n          /**\n           * @note Bind the forwarded original server events\n           * to the mock WebSocket instance so it would\n           * dispatch them straight away.\n           */\n          this.client,\n          // Clone the message event again to prevent\n          // the \"already being dispatched\" exception.\n          new MessageEvent('message', {\n            data: event.data,\n            origin: event.origin,\n          })\n        )\n      )\n    }\n  }\n\n  private handleMockClose(_event: Event): void {\n    // Close the original connection if the mock client closes.\n    if (this.realWebSocket) {\n      this.realWebSocket.close()\n    }\n  }\n\n  private handleRealClose(event: CloseEvent): void {\n    // For closures originating from the original server,\n    // remove the \"close\" listener from the mock client.\n    // original close -> (?) client[kClose]() --X--> \"close\" (again).\n    this.mockCloseController.abort()\n\n    const closeEvent = bindEvent(\n      this.realWebSocket,\n      new CancelableCloseEvent('close', {\n        code: event.code,\n        reason: event.reason,\n        wasClean: event.wasClean,\n        cancelable: true,\n      })\n    )\n\n    this[kEmitter].dispatchEvent(closeEvent)\n\n    // If the close event from the server hasn't been prevented,\n    // forward the closure to the mock client.\n    if (!closeEvent.defaultPrevented) {\n      // Close the intercepted client forcefully to\n      // allow non-configurable status codes from the server.\n      // If the socket has been closed by now, no harm calling\n      // this againâ€”it will have no effect.\n      this.client[kClose](event.code, event.reason)\n    }\n  }\n}\n", "import { bindEvent } from './utils/bindEvent'\nimport {\n  StrictEventListenerOrEventListenerObject,\n  WebSocketData,\n  WebSocketTransport,\n  WebSocketTransportEventMap,\n} from './WebSocketTransport'\nimport { kOnSend, kClose, WebSocketOverride } from './WebSocketOverride'\nimport { CancelableMessageEvent, CloseEvent } from './utils/events'\n\n/**\n * Abstraction over the given mock `WebSocket` instance that allows\n * for controlling that instance (e.g. sending and receiving messages).\n */\nexport class WebSocketClassTransport\n  extends EventTarget\n  implements WebSocketTransport\n{\n  constructor(protected readonly socket: WebSocketOverride) {\n    super()\n\n    // Emit the \"close\" event on the transport if the close\n    // originates from the WebSocket client. E.g. the application\n    // calls \"ws.close()\", not the interceptor.\n    this.socket.addEventListener('close', (event) => {\n      this.dispatchEvent(bindEvent(this.socket, new CloseEvent('close', event)))\n    })\n\n    /**\n     * Emit the \"outgoing\" event on the transport\n     * whenever the WebSocket client sends data (\"ws.send()\").\n     */\n    this.socket[kOnSend] = (data) => {\n      this.dispatchEvent(\n        bindEvent(\n          this.socket,\n          // Dispatch this as cancelable because \"client\" connection\n          // re-creates this message event (cannot dispatch the same event).\n          new CancelableMessageEvent('outgoing', {\n            data,\n            origin: this.socket.url,\n            cancelable: true,\n          })\n        )\n      )\n    }\n  }\n\n  public addEventListener<EventType extends keyof WebSocketTransportEventMap>(\n    type: EventType,\n    callback: StrictEventListenerOrEventListenerObject<\n      WebSocketTransportEventMap[EventType]\n    > | null,\n    options?: boolean | AddEventListenerOptions\n  ): void {\n    return super.addEventListener(type, callback as EventListener, options)\n  }\n\n  public dispatchEvent<EventType extends keyof WebSocketTransportEventMap>(\n    event: WebSocketTransportEventMap[EventType]\n  ): boolean {\n    return super.dispatchEvent(event)\n  }\n\n  public send(data: WebSocketData): void {\n    queueMicrotask(() => {\n      if (\n        this.socket.readyState === this.socket.CLOSING ||\n        this.socket.readyState === this.socket.CLOSED\n      ) {\n        return\n      }\n\n      const dispatchEvent = () => {\n        this.socket.dispatchEvent(\n          bindEvent(\n            /**\n             * @note Setting this event's \"target\" to the\n             * WebSocket override instance is important.\n             * This way it can tell apart original incoming events\n             * (must be forwarded to the transport) from the\n             * mocked message events like the one below\n             * (must be dispatched on the client instance).\n             */\n            this.socket,\n            new MessageEvent('message', {\n              data,\n              origin: this.socket.url,\n            })\n          )\n        )\n      }\n\n      if (this.socket.readyState === this.socket.CONNECTING) {\n        this.socket.addEventListener(\n          'open',\n          () => {\n            dispatchEvent()\n          },\n          { once: true }\n        )\n      } else {\n        dispatchEvent()\n      }\n    })\n  }\n\n  public close(code: number, reason?: string): void {\n    /**\n     * @note Call the internal close method directly\n     * to allow closing the connection with the status codes\n     * that are non-configurable by the user (> 1000 <= 1015).\n     */\n    this.socket[kClose](code, reason)\n  }\n}\n", "import { Interceptor } from '../../Interceptor'\nimport {\n  WebSocketClientConnectionProtocol,\n  WebSocketClientConnection,\n  type WebSocketClientEventMap,\n} from './WebSocketClientConnection'\nimport {\n  WebSocketServerConnectionProtocol,\n  WebSocketServerConnection,\n  type WebSocketServerEventMap,\n} from './WebSocketServerConnection'\nimport { WebSocketClassTransport } from './WebSocketClassTransport'\nimport {\n  kClose,\n  kPassthroughPromise,\n  WebSocketOverride,\n} from './WebSocketOverride'\nimport { bindEvent } from './utils/bindEvent'\nimport { hasConfigurableGlobal } from '../../utils/hasConfigurableGlobal'\nimport { emitAsync } from '../../utils/emitAsync'\n\nexport {\n  type WebSocketData,\n  type WebSocketTransport,\n} from './WebSocketTransport'\nexport {\n  WebSocketClientEventMap,\n  WebSocketClientConnectionProtocol,\n  WebSocketClientConnection,\n  WebSocketServerEventMap,\n  WebSocketServerConnectionProtocol,\n  WebSocketServerConnection,\n}\n\nexport {\n  CloseEvent,\n  CancelableCloseEvent,\n  CancelableMessageEvent,\n} from './utils/events'\n\nexport type WebSocketEventMap = {\n  connection: [args: WebSocketConnectionData]\n}\n\nexport type WebSocketConnectionData = {\n  /**\n   * The incoming WebSocket client connection.\n   */\n  client: WebSocketClientConnection\n\n  /**\n   * The original WebSocket server connection.\n   */\n  server: WebSocketServerConnection\n\n  /**\n   * The connection information.\n   */\n  info: {\n    /**\n     * The protocols supported by the WebSocket client.\n     */\n    protocols: string | Array<string> | undefined\n  }\n}\n\n/**\n * Intercept the outgoing WebSocket connections created using\n * the global `WebSocket` class.\n */\nexport class WebSocketInterceptor extends Interceptor<WebSocketEventMap> {\n  static symbol = Symbol('websocket')\n\n  constructor() {\n    super(WebSocketInterceptor.symbol)\n  }\n\n  protected checkEnvironment(): boolean {\n    return hasConfigurableGlobal('WebSocket')\n  }\n\n  protected setup(): void {\n    const originalWebSocketDescriptor = Object.getOwnPropertyDescriptor(\n      globalThis,\n      'WebSocket'\n    )\n\n    const WebSocketProxy = new Proxy(globalThis.WebSocket, {\n      construct: (\n        target,\n        args: ConstructorParameters<typeof globalThis.WebSocket>,\n        newTarget\n      ) => {\n        const [url, protocols] = args\n\n        const createConnection = (): WebSocket => {\n          return Reflect.construct(target, args, newTarget)\n        }\n\n        // All WebSocket instances are mocked and don't forward\n        // any events to the original server (no connection established).\n        // To forward the events, the user must use the \"server.send()\" API.\n        const socket = new WebSocketOverride(url, protocols)\n        const transport = new WebSocketClassTransport(socket)\n\n        // Emit the \"connection\" event to the interceptor on the next tick\n        // so the client can modify WebSocket options, like \"binaryType\"\n        // while the connection is already pending.\n        queueMicrotask(async () => {\n          try {\n            const server = new WebSocketServerConnection(\n              socket,\n              transport,\n              createConnection\n            )\n\n            const hasConnectionListeners =\n              this.emitter.listenerCount('connection') > 0\n\n            // The \"globalThis.WebSocket\" class stands for\n            // the client-side connection. Assume it's established\n            // as soon as the WebSocket instance is constructed.\n            await emitAsync(this.emitter, 'connection', {\n              client: new WebSocketClientConnection(socket, transport),\n              server,\n              info: {\n                protocols,\n              },\n            })\n\n            if (hasConnectionListeners) {\n              socket[kPassthroughPromise].resolve(false)\n            } else {\n              socket[kPassthroughPromise].resolve(true)\n\n              server.connect()\n\n              // Forward the \"open\" event from the original server\n              // to the mock WebSocket client in the case of a passthrough connection.\n              server.addEventListener('open', () => {\n                socket.dispatchEvent(bindEvent(socket, new Event('open')))\n\n                // Forward the original connection protocol to the\n                // mock WebSocket client.\n                if (server['realWebSocket']) {\n                  socket.protocol = server['realWebSocket'].protocol\n                }\n              })\n            }\n          } catch (error) {\n            /**\n             * @note Translate unhandled exceptions during the connection\n             * handling (i.e. interceptor exceptions) as WebSocket connection\n             * closures with error. This prevents from the exceptions occurring\n             * in `queueMicrotask` from being process-wide and uncatchable.\n             */\n            if (error instanceof Error) {\n              socket.dispatchEvent(new Event('error'))\n\n              // No need to close the connection if it's already being closed.\n              // E.g. the interceptor called `client.close()` and then threw an error.\n              if (\n                socket.readyState !== WebSocket.CLOSING &&\n                socket.readyState !== WebSocket.CLOSED\n              ) {\n                socket[kClose](1011, error.message, false)\n              }\n\n              console.error(error)\n            }\n          }\n        })\n\n        return socket\n      },\n    })\n\n    Object.defineProperty(globalThis, 'WebSocket', {\n      value: WebSocketProxy,\n      configurable: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(\n        globalThis,\n        'WebSocket',\n        originalWebSocketDescriptor!\n      )\n    })\n  }\n}\n", "import { WebSocketInterceptor } from '@mswjs/interceptors/WebSocket'\n\nexport const webSocketInterceptor = new WebSocketInterceptor()\n", "import type { WebSocketConnectionData } from '@mswjs/interceptors/WebSocket'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { WebSocketHandler } from '../handlers/WebSocketHandler'\nimport { webSocketInterceptor } from './webSocketInterceptor'\nimport {\n  onUnhandledRequest,\n  UnhandledRequestStrategy,\n} from '../utils/request/onUnhandledRequest'\nimport { isHandlerKind } from '../utils/internal/isHandlerKind'\n\ninterface HandleWebSocketEventOptions {\n  getUnhandledRequestStrategy: () => UnhandledRequestStrategy\n  getHandlers: () => Array<RequestHandler | WebSocketHandler>\n  onMockedConnection: (connection: WebSocketConnectionData) => void\n  onPassthroughConnection: (onnection: WebSocketConnectionData) => void\n}\n\nexport function handleWebSocketEvent(options: HandleWebSocketEventOptions) {\n  webSocketInterceptor.on('connection', async (connection) => {\n    const handlers = options.getHandlers().filter(isHandlerKind('EventHandler'))\n\n    // Ignore this connection if the user hasn't defined any handlers.\n    if (handlers.length > 0) {\n      options?.onMockedConnection(connection)\n\n      await Promise.all(\n        handlers.map((handler) => {\n          // Iterate over the handlers and forward the connection\n          // event to WebSocket event handlers. This is equivalent\n          // to dispatching that event onto multiple listeners.\n          return handler.run(connection)\n        }),\n      )\n\n      return\n    }\n\n    // Construct a request representing this WebSocket connection.\n    const request = new Request(connection.client.url, {\n      headers: {\n        upgrade: 'websocket',\n        connection: 'upgrade',\n      },\n    })\n    await onUnhandledRequest(\n      request,\n      options.getUnhandledRequestStrategy(),\n    ).catch((error) => {\n      const errorEvent = new Event('error')\n      Object.defineProperty(errorEvent, 'cause', {\n        enumerable: true,\n        configurable: false,\n        value: error,\n      })\n      connection.client.socket.dispatchEvent(errorEvent)\n    })\n\n    options?.onPassthroughConnection(connection)\n\n    // If none of the \"ws\" handlers matched,\n    // establish the WebSocket connection as-is.\n    connection.server.connect()\n  })\n}\n", "const POSITIONALS_EXP = /(%?)(%([sdijo]))/g\n\nfunction serializePositional(positional: any, flag: string): any {\n  switch (flag) {\n    // Strings.\n    case 's':\n      return positional\n\n    // Digits.\n    case 'd':\n    case 'i':\n      return Number(positional)\n\n    // JSON.\n    case 'j':\n      return JSON.stringify(positional)\n\n    // Objects.\n    case 'o': {\n      // Preserve stings to prevent extra quotes around them.\n      if (typeof positional === 'string') {\n        return positional\n      }\n\n      const json = JSON.stringify(positional)\n\n      // If the positional isn't serializable, return it as-is.\n      if (json === '{}' || json === '[]' || /^\\[object .+?\\]$/.test(json)) {\n        return positional\n      }\n\n      return json\n    }\n  }\n}\n\nexport function format(message: string, ...positionals: any[]): string {\n  if (positionals.length === 0) {\n    return message\n  }\n\n  let positionalIndex = 0\n  let formattedMessage = message.replace(\n    POSITIONALS_EXP,\n    (match, isEscaped, _, flag) => {\n      const positional = positionals[positionalIndex]\n      const value = serializePositional(positional, flag)\n\n      if (!isEscaped) {\n        positionalIndex++\n        return value\n      }\n\n      return match\n    }\n  )\n\n  // Append unresolved positionals to string as-is.\n  if (positionalIndex < positionals.length) {\n    formattedMessage += ` ${positionals.slice(positionalIndex).join(' ')}`\n  }\n\n  formattedMessage = formattedMessage.replace(/%{2,2}/g, '%')\n\n  return formattedMessage\n}\n", "import { format } from './format'\n\nconst STACK_FRAMES_TO_IGNORE = 2\n\n/**\n * Remove the \"outvariant\" package trace from the given error.\n * This scopes down the error stack to the relevant parts\n * when used in other applications.\n */\nfunction cleanErrorStack(error: Error): void {\n  if (!error.stack) {\n    return\n  }\n\n  const nextStack = error.stack.split('\\n')\n  nextStack.splice(1, STACK_FRAMES_TO_IGNORE)\n  error.stack = nextStack.join('\\n')\n}\n\nexport class InvariantError extends Error {\n  name = 'Invariant Violation'\n\n  constructor(public readonly message: string, ...positionals: any[]) {\n    super(message)\n    this.message = format(message, ...positionals)\n    cleanErrorStack(this)\n  }\n}\n\nexport interface CustomErrorConstructor {\n  new (message: string): Error\n}\n\nexport interface CustomErrorFactory {\n  (message: string): Error\n}\n\nexport type CustomError = CustomErrorConstructor | CustomErrorFactory\n\ntype Invariant = {\n  (\n    predicate: unknown,\n    message: string,\n    ...positionals: any[]\n  ): asserts predicate\n\n  as(\n    ErrorConstructor: CustomError,\n    predicate: unknown,\n    message: string,\n    ...positionals: unknown[]\n  ): asserts predicate\n}\n\nexport const invariant: Invariant = (\n  predicate,\n  message,\n  ...positionals\n): asserts predicate => {\n  if (!predicate) {\n    throw new InvariantError(message, ...positionals)\n  }\n}\n\ninvariant.as = (ErrorConstructor, predicate, message, ...positionals) => {\n  if (!predicate) {\n    const formatMessage =\n      positionals.length === 0 ? message : format(message, ...positionals)\n    let error: Error\n\n    try {\n      error = Reflect.construct(ErrorConstructor as CustomErrorConstructor, [\n        formatMessage,\n      ])\n    } catch (err) {\n      error = (ErrorConstructor as CustomErrorFactory)(formatMessage)\n    }\n\n    throw error\n  }\n}\n", "/**\n * Determines if the current process is a Node.js process.\n */\nexport function isNodeProcess(): boolean {\n  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {\n    return true\n  }\n\n  if (typeof process !== 'undefined') {\n    // Electron (https://www.electronjs.org/docs/latest/api/process#processtype-readonly)\n    const type = (process as any).type\n    if (type === 'renderer' || type === 'worker') {\n      return false\n    }\n\n\n    return !!(\n      process.versions &&\n      process.versions.node\n    )\n  }\n\n  return false\n}\n", "export type PromiseState = 'pending' | 'fulfilled' | 'rejected'\n\nexport type Executor<Value> = ConstructorParameters<typeof Promise<Value>>[0]\nexport type ResolveFunction<Value> = Parameters<Executor<Value>>[0]\nexport type RejectFunction<Reason> = Parameters<Executor<Reason>>[1]\n\nexport type DeferredPromiseExecutor<Input = never, Output = Input> = {\n  (resolve?: ResolveFunction<Input>, reject?: RejectFunction<any>): void\n\n  resolve: ResolveFunction<Input>\n  reject: RejectFunction<any>\n  result?: Output\n  state: PromiseState\n  rejectionReason?: unknown\n}\nexport function createDeferredExecutor<\n  Input = never,\n  Output = Input\n>(): DeferredPromiseExecutor<Input, Output> {\n  const executor = <DeferredPromiseExecutor<Input, Output>>((\n    resolve,\n    reject\n  ) => {\n    executor.state = 'pending'\n\n    executor.resolve = (data) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      executor.result = data as Output\n\n      const onFulfilled = <Value>(value: Value) => {\n        executor.state = 'fulfilled'\n        return value\n      }\n\n      return resolve(\n        data instanceof Promise ? data : Promise.resolve(data).then(onFulfilled)\n      )\n    }\n\n    executor.reject = (reason) => {\n      if (executor.state !== 'pending') {\n        return\n      }\n\n      queueMicrotask(() => {\n        executor.state = 'rejected'\n      })\n\n      return reject((executor.rejectionReason = reason))\n    }\n  })\n\n  return executor\n}\n", "import {\n  type Executor,\n  type RejectFunction,\n  type ResolveFunction,\n  type DeferredPromiseExecutor,\n  createDeferredExecutor,\n} from './createDeferredExecutor'\n\nexport class DeferredPromise<Input, Output = Input> extends Promise<Input> {\n  #executor: DeferredPromiseExecutor\n\n  public resolve: ResolveFunction<Output>\n  public reject: RejectFunction<Output>\n\n  constructor(executor: Executor<Input> | null = null) {\n    const deferredExecutor = createDeferredExecutor()\n    super((originalResolve, originalReject) => {\n      deferredExecutor(originalResolve, originalReject)\n      executor?.(deferredExecutor.resolve, deferredExecutor.reject)\n    })\n\n    this.#executor = deferredExecutor\n    this.resolve = this.#executor.resolve\n    this.reject = this.#executor.reject\n  }\n\n  public get state() {\n    return this.#executor.state\n  }\n\n  public get rejectionReason() {\n    return this.#executor.rejectionReason\n  }\n\n  public then<ThenResult = Input, CatchResult = never>(\n    onFulfilled?: (value: Input) => ThenResult | PromiseLike<ThenResult>,\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.then(onFulfilled, onRejected))\n  }\n\n  public catch<CatchResult = never>(\n    onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>\n  ) {\n    return this.#decorate(super.catch(onRejected))\n  }\n\n  public finally(onfinally?: () => void | Promise<any>) {\n    return this.#decorate(super.finally(onfinally))\n  }\n\n  #decorate<ChildInput>(\n    promise: Promise<ChildInput>\n  ): DeferredPromise<ChildInput, Output> {\n    return Object.defineProperties(promise, {\n      resolve: { configurable: true, value: this.resolve },\n      reject: { configurable: true, value: this.reject },\n    }) as DeferredPromise<ChildInput, Output>\n  }\n}\n", "import { RequiredDeep } from '~/core/typeUtils'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport {\n  SetupWorker,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorker['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n", "import { devUtils } from '~/core/utils/internal/devUtils'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport type { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from './createRequestListener'\nimport { checkWorkerIntegrity } from '../../utils/checkWorkerIntegrity'\nimport { createResponseListener } from './createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.workerChannel.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      // Handle responses signaled by the worker.\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.workerPromise.resolve(worker)\n      context.registration = registration\n\n      window.addEventListener('beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.postMessage('CLIENT_CLOSED')\n        }\n\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n\n        // Notify others about this client disconnecting.\n        // E.g. this will purge the in-memory WebSocket clients since\n        // starting the worker again will assign them new IDs.\n        window.postMessage({ type: 'msw/worker:stop' })\n      })\n\n      // Check if the active Service Worker has been generated\n      // by the currently installed version of MSW.\n      await checkWorkerIntegrity(context).catch((error) => {\n        devUtils.error(\n          'Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.',\n        )\n        console.error(error)\n      })\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.postMessage('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        if (pendingInstance) {\n          const activationPromise = new DeferredPromise<void>()\n\n          pendingInstance.addEventListener('statechange', () => {\n            if (pendingInstance.state === 'activated') {\n              activationPromise.resolve()\n            }\n          })\n\n          // Wait until the worker is activated.\n          // Assume the worker is already activated if there's no pending registration\n          // (i.e. when reloading the page after a successful activation).\n          await activationPromise\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          devUtils.error(\n            'Failed to enable mocking. Please report this on GitHub (https://github.com/mswjs/msw/issues) and include the original error below.',\n          )\n          throw error\n        })\n\n        return registration\n      },\n    )\n\n    return workerRegistration\n  }\n}\n", "export type UntilResult<RejectionReason, ResolveData> =\n  | [reason: RejectionReason, data: null]\n  | [reason: null, data: ResolveData]\n\n/**\n * Gracefully handles a callback that returns a promise.\n *\n * @example\n * await until(() => Promise.resolve(123))\n * // [null, 123]\n *\n * await until(() => Promise.reject(new Error('Oops!')))\n * // [new Error('Oops!'), null]\n */\nexport async function until<RejectionReason = Error, ResolveData = unknown>(\n  callback: () => Promise<ResolveData>,\n): Promise<UntilResult<RejectionReason, ResolveData>> {\n  try {\n    const data = await callback().catch((error) => {\n      throw error\n    })\n    return [null, data]\n  } catch (error: any) {\n    return [error, null]\n  }\n}\n", "import { until } from 'until-async'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { getAbsoluteWorkerUrl } from '../../../utils/getAbsoluteWorkerUrl'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // Schedule the worker update in the background.\n    // Update ensures the existing worker is up-to-date.\n    existingRegistration.update()\n\n    // Return the worker reference immediately.\n    return [\n      getWorkerByRegistration(\n        existingRegistration,\n        absoluteWorkerUrl,\n        findWorker,\n      ),\n      existingRegistration,\n    ]\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const [registrationError, registrationResult] = await until<\n    Error,\n    ServiceWorkerInstanceTuple\n  >(async () => {\n    const registration = await navigator.serviceWorker.register(url, options)\n    return [\n      // Compare existing worker registration by its worker URL,\n      // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n      getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      registration,\n    ]\n  })\n\n  // Handle Service Worker registration errors.\n  if (registrationError) {\n    const isWorkerMissing = registrationError.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        registrationError.message,\n      ),\n    )\n  }\n\n  return registrationResult\n}\n", "/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(workerUrl: string): string {\n  return new URL(workerUrl, location.href).href\n}\n", "import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport function getWorkerByRegistration(\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const relevantStates = allStates.filter((state): state is ServiceWorker => {\n    return state != null\n  })\n  const worker = relevantStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return worker || null\n}\n", "import type { ServiceWorkerIncomingEventsMap } from '../../glossary'\nimport { devUtils } from '~/core/utils/internal/devUtils'\n\ninterface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n  client?: ServiceWorkerIncomingEventsMap['MOCKING_ENABLED']['client']\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  // eslint-disable-next-line no-console\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  // eslint-disable-next-line no-console\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    // eslint-disable-next-line no-console\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    // eslint-disable-next-line no-console\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  if (args.client) {\n    // eslint-disable-next-line no-console\n    console.log('Client ID: %s (%s)', args.client.id, args.client.frameType)\n  }\n\n  console.groupEnd()\n}\n", "import { DeferredPromise } from '@open-draft/deferred-promise'\nimport type { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n): Promise<boolean> {\n  const mockingEnabledPromise = new DeferredPromise<boolean>()\n\n  context.workerChannel.postMessage('MOCK_ACTIVATE')\n  context.workerChannel.once('MOCKING_ENABLED', async (event) => {\n    context.isMockingEnabled = true\n    const worker = await context.workerPromise\n\n    printStartMessage({\n      quiet: options.quiet,\n      workerScope: context.registration?.scope,\n      workerUrl: worker.scriptURL,\n      client: event.data.client,\n    })\n\n    mockingEnabledPromise.resolve(true)\n  })\n\n  return mockingEnabledPromise\n}\n", "import type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\ntype Input = Pick<ServiceWorkerIncomingRequest, 'method' | 'body'>\n\n/**\n * Ensures that an empty GET request body is always represented as `undefined`.\n */\nexport function pruneGetRequestBody(\n  request: Input,\n): ServiceWorkerIncomingRequest['body'] {\n  // Force HEAD/GET request body to always be empty.\n  // The worker reads any request's body as ArrayBuffer,\n  // and you cannot re-construct a GET/HEAD Request\n  // with an ArrayBuffer, even if empty. Also note that\n  // \"request.body\" is always undefined in the worker.\n  if (['HEAD', 'GET'].includes(request.method)) {\n    return undefined\n  }\n\n  return request.body\n}\n", "import { pruneGetRequestBody } from './pruneGetRequestBody'\nimport type { ServiceWorkerIncomingRequest } from '../setupWorker/glossary'\n\n/**\n * Converts a given request received from the Service Worker\n * into a Fetch `Request` instance.\n */\nexport function deserializeRequest(\n  serializedRequest: ServiceWorkerIncomingRequest,\n): Request {\n  return new Request(serializedRequest.url, {\n    ...serializedRequest,\n    body: pruneGetRequestBody(serializedRequest),\n  })\n}\n", "/**\n * Checks if the Service Worker API is supproted and available\n * in the current browsing context.\n */\nexport function supportsServiceWorker(): boolean {\n  return (\n    typeof navigator !== 'undefined' &&\n    'serviceWorker' in navigator &&\n    typeof location !== 'undefined' &&\n    location.protocol !== 'file:'\n  )\n}\n\n/**\n * Returns a boolean indicating whether the current browser\n * supports `ReadableStream` as a `Transferable` when posting\n * messages.\n */\nexport function supportsReadableStreamTransfer() {\n  try {\n    const stream = new ReadableStream({\n      start: (controller) => controller.close(),\n    })\n    const message = new MessageChannel()\n    message.port1.postMessage(stream, [stream])\n    return true\n  } catch {\n    return false\n  }\n}\n", "import { Emitter } from 'rettime'\nimport { StartOptions, SetupWorkerInternalContext } from '../glossary'\nimport { deserializeRequest } from '../../utils/deserializeRequest'\nimport { supportsReadableStreamTransfer } from '../../utils/supports'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { handleRequest } from '~/core/utils/handleRequest'\nimport { RequiredDeep } from '~/core/typeUtils'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { toResponseInit } from '~/core/utils/toResponseInit'\nimport { isHandlerKind } from '~/core/utils/internal/isHandlerKind'\n\nconst SUPPORTS_READABLE_STREAM_TRANSFER = supportsReadableStreamTransfer()\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Emitter.ListenerType<typeof context.workerChannel, 'REQUEST'> => {\n  return async (event) => {\n    // Treat any incoming requests from the worker as passthrough\n    // if `worker.stop()` has been called for this client.\n    if (\n      !context.isMockingEnabled &&\n      context.workerStoppedAt &&\n      event.data.interceptedAt > context.workerStoppedAt\n    ) {\n      event.postMessage('PASSTHROUGH')\n      return\n    }\n\n    const requestId = event.data.id\n    const request = deserializeRequest(event.data)\n    const requestCloneForLogs = request.clone()\n\n    // Make this the first request clone before the\n    // request resolution pipeline even starts.\n    // Store the clone in cache so the first matching\n    // request handler would skip the cloning phase.\n    const requestClone = request.clone()\n    RequestHandler.cache.set(request, requestClone)\n\n    try {\n      await handleRequest(\n        request,\n        requestId,\n        context.getRequestHandlers().filter(isHandlerKind('RequestHandler')),\n        options,\n        context.emitter,\n        {\n          resolutionContext: {\n            quiet: options.quiet,\n          },\n          onPassthroughResponse() {\n            event.postMessage('PASSTHROUGH')\n          },\n          async onMockedResponse(response, { handler, parsedResult }) {\n            // Clone the mocked response so its body could be read\n            // to buffer to be sent to the worker and also in the\n            // \".log()\" method of the request handler.\n            const responseClone = response.clone()\n            const responseCloneForLogs = response.clone()\n            const responseInit = toResponseInit(response)\n\n            /**\n             * @note Safari doesn't support transferring a \"ReadableStream\".\n             * Check that the browser supports that before sending it to the worker.\n             */\n            if (SUPPORTS_READABLE_STREAM_TRANSFER) {\n              const responseStreamOrNull = response.body\n\n              event.postMessage(\n                'MOCK_RESPONSE',\n                {\n                  ...responseInit,\n                  body: responseStreamOrNull,\n                },\n                responseStreamOrNull ? [responseStreamOrNull] : undefined,\n              )\n            } else {\n              /**\n               * @note If we are here, this means the current environment doesn't\n               * support \"ReadableStream\" as transferable. In that case,\n               * attempt to read the non-empty response body as ArrayBuffer, if it's not empty.\n               * @see https://github.com/mswjs/msw/issues/1827\n               */\n              const responseBufferOrNull =\n                response.body === null\n                  ? null\n                  : await responseClone.arrayBuffer()\n\n              event.postMessage('MOCK_RESPONSE', {\n                ...responseInit,\n                body: responseBufferOrNull,\n              })\n            }\n\n            if (!options.quiet) {\n              context.emitter.once('response:mocked', () => {\n                handler.log({\n                  request: requestCloneForLogs,\n                  response: responseCloneForLogs,\n                  parsedResult,\n                })\n              })\n            }\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/http/mocking-responses/error-responses`,\n          request.method,\n          request.url,\n          error.stack ?? error,\n        )\n\n        // Treat all other exceptions in a request handler as unintended,\n        // alerting that there is a problem that needs fixing.\n        event.postMessage('MOCK_RESPONSE', {\n          status: 500,\n          statusText: 'Request Handler Error',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          }),\n        })\n      }\n    }\n  }\n}\n", "import { devUtils } from '~/core/utils/internal/devUtils'\nimport type { SetupWorkerInternalContext } from '../setupWorker/glossary'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\n\n/**\n * Check whether the registered Service Worker has been\n * generated by the installed version of the library.\n * Prints a warning message if the worker scripts mismatch.\n */\nexport function checkWorkerIntegrity(\n  context: SetupWorkerInternalContext,\n): Promise<void> {\n  const integrityCheckPromise = new DeferredPromise<void>()\n\n  // Request the integrity checksum from the registered worker.\n  context.workerChannel.postMessage('INTEGRITY_CHECK_REQUEST')\n  context.workerChannel.once('INTEGRITY_CHECK_RESPONSE', (event) => {\n    const { checksum, packageVersion } = event.data\n\n    // Compare the response from the Service Worker and the\n    // global variable set during the build.\n\n    // The integrity is validated based on the worker script's checksum\n    // that's derived from its minified content during the build.\n    // The \"SERVICE_WORKER_CHECKSUM\" global variable is injected by the build.\n    if (checksum !== SERVICE_WORKER_CHECKSUM) {\n      devUtils.warn(\n        `The currently registered Service Worker has been generated by a different version of MSW (${packageVersion}) and may not be fully compatible with the installed version.\n\nIt's recommended you update your worker script by running this command:\n\n  \\u2022 npx msw init <PUBLIC_DIR>\n\nYou can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`,\n      )\n    }\n\n    integrityCheckPromise.resolve()\n  })\n\n  return integrityCheckPromise\n}\n", "import type { RequestController } from './RequestController'\n\nexport const IS_PATCHED_MODULE: unique symbol = Symbol('isPatchedModule')\n\n/**\n * @note Export `RequestController` as a type only.\n * It's never meant to be created in the userland.\n */\nexport type { RequestController }\n\nexport type RequestCredentials = 'omit' | 'include' | 'same-origin'\n\nexport type HttpRequestEventMap = {\n  request: [\n    args: {\n      request: Request\n      requestId: string\n      controller: RequestController\n    }\n  ]\n  response: [\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ]\n  unhandledException: [\n    args: {\n      error: unknown\n      request: Request\n      requestId: string\n      controller: RequestController\n    }\n  ]\n}\n", "export class InterceptorError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = 'InterceptorError'\n    Object.setPrototypeOf(this, InterceptorError.prototype)\n  }\n}\n", "import { DeferredPromise } from '@open-draft/deferred-promise'\nimport { invariant } from 'outvariant'\nimport { InterceptorError } from './InterceptorError'\n\nexport interface RequestControllerSource {\n  passthrough(): void\n  respondWith(response: Response): void\n  errorWith(reason?: unknown): void\n}\n\nexport class RequestController {\n  static PENDING = 0 as const\n  static PASSTHROUGH = 1 as const\n  static RESPONSE = 2 as const\n  static ERROR = 3 as const\n\n  public readyState: number\n\n  /**\n   * A Promise that resolves when this controller handles a request.\n   * See `controller.readyState` for more information on the handling result.\n   */\n  public handled: Promise<void>\n\n  constructor(\n    protected readonly request: Request,\n    protected readonly source: RequestControllerSource\n  ) {\n    this.readyState = RequestController.PENDING\n    this.handled = new DeferredPromise<void>()\n  }\n\n  get #handled() {\n    return this.handled as DeferredPromise<void>\n  }\n\n  /**\n   * Perform this request as-is.\n   */\n  public async passthrough(): Promise<void> {\n    invariant.as(\n      InterceptorError,\n      this.readyState === RequestController.PENDING,\n      'Failed to passthrough the \"%s %s\" request: the request has already been handled',\n      this.request.method,\n      this.request.url\n    )\n\n    this.readyState = RequestController.PASSTHROUGH\n    await this.source.passthrough()\n    this.#handled.resolve()\n  }\n\n  /**\n   * Respond to this request with the given `Response` instance.\n   *\n   * @example\n   * controller.respondWith(new Response())\n   * controller.respondWith(Response.json({ id }))\n   * controller.respondWith(Response.error())\n   */\n  public respondWith(response: Response): void {\n    invariant.as(\n      InterceptorError,\n      this.readyState === RequestController.PENDING,\n      'Failed to respond to the \"%s %s\" request with \"%d %s\": the request has already been handled (%d)',\n      this.request.method,\n      this.request.url,\n      response.status,\n      response.statusText || 'OK',\n      this.readyState\n    )\n\n    this.readyState = RequestController.RESPONSE\n    this.#handled.resolve()\n\n    /**\n     * @note Although `source.respondWith()` is potentially asynchronous,\n     * do NOT await it for backward-compatibility. Awaiting it will short-circuit\n     * the request listener invocation as soon as a listener responds to a request.\n     * Ideally, that's what we want, but that's not what we promise the user.\n     */\n    this.source.respondWith(response)\n  }\n\n  /**\n   * Error this request with the given reason.\n   *\n   * @example\n   * controller.errorWith()\n   * controller.errorWith(new Error('Oops!'))\n   * controller.errorWith({ message: 'Oops!'})\n   */\n  public errorWith(reason?: unknown): void {\n    invariant.as(\n      InterceptorError,\n      this.readyState === RequestController.PENDING,\n      'Failed to error the \"%s %s\" request with \"%s\": the request has already been handled (%d)',\n      this.request.method,\n      this.request.url,\n      reason?.toString(),\n      this.readyState\n    )\n\n    this.readyState = RequestController.ERROR\n    this.source.errorWith(reason)\n    this.#handled.resolve()\n  }\n}\n", "/**\n * Returns a boolean indicating whether the given URL string\n * can be parsed into a `URL` instance.\n * A substitute for `URL.canParse()` for Node.js 18.\n */\nexport function canParseUrl(url: string): boolean {\n  try {\n    new URL(url)\n    return true\n  } catch (_error) {\n    return false\n  }\n}\n", "/**\n * Returns the value behind the symbol with the given name.\n */\nexport function getValueBySymbol<T>(\n  symbolName: string,\n  source: object\n): T | undefined {\n  const ownSymbols = Object.getOwnPropertySymbols(source)\n\n  const symbol = ownSymbols.find((symbol) => {\n    return symbol.description === symbolName\n  })\n\n  if (symbol) {\n    return Reflect.get(source, symbol)\n  }\n\n  return\n}\n", "import { canParseUrl } from './canParseUrl'\nimport { getValueBySymbol } from './getValueBySymbol'\n\nexport interface FetchResponseInit extends ResponseInit {\n  url?: string\n}\n\ninterface UndiciFetchInternalState {\n  aborted: boolean\n  rangeRequested: boolean\n  timingAllowPassed: boolean\n  requestIncludesCredentials: boolean\n  type: ResponseType\n  status: number\n  statusText: string\n  timingInfo: unknown\n  cacheState: unknown\n  headersList: Record<symbol, Map<string, unknown>>\n  urlList: Array<URL>\n  body?: {\n    stream: ReadableStream\n    source: unknown\n    length: number\n  }\n}\n\nexport class FetchResponse extends Response {\n  /**\n   * Response status codes for responses that cannot have body.\n   * @see https://fetch.spec.whatwg.org/#statuses\n   */\n  static readonly STATUS_CODES_WITHOUT_BODY = [101, 103, 204, 205, 304]\n\n  static readonly STATUS_CODES_WITH_REDIRECT = [301, 302, 303, 307, 308]\n\n  static isConfigurableStatusCode(status: number): boolean {\n    return status >= 200 && status <= 599\n  }\n\n  static isRedirectResponse(status: number): boolean {\n    return FetchResponse.STATUS_CODES_WITH_REDIRECT.includes(status)\n  }\n\n  /**\n   * Returns a boolean indicating whether the given response status\n   * code represents a response that can have a body.\n   */\n  static isResponseWithBody(status: number): boolean {\n    return !FetchResponse.STATUS_CODES_WITHOUT_BODY.includes(status)\n  }\n\n  static setUrl(url: string | undefined, response: Response): void {\n    if (!url || url === 'about:' || !canParseUrl(url)) {\n      return\n    }\n\n    const state = getValueBySymbol<UndiciFetchInternalState>('state', response)\n\n    if (state) {\n      // In Undici, push the URL to the internal list of URLs.\n      // This will respect the `response.url` getter logic correctly.\n      state.urlList.push(new URL(url))\n    } else {\n      // In other libraries, redefine the `url` property directly.\n      Object.defineProperty(response, 'url', {\n        value: url,\n        enumerable: true,\n        configurable: true,\n        writable: false,\n      })\n    }\n  }\n\n  /**\n   * Parses the given raw HTTP headers into a Fetch API `Headers` instance.\n   */\n  static parseRawHeaders(rawHeaders: Array<string>): Headers {\n    const headers = new Headers()\n    for (let line = 0; line < rawHeaders.length; line += 2) {\n      headers.append(rawHeaders[line], rawHeaders[line + 1])\n    }\n    return headers\n  }\n\n  constructor(body?: BodyInit | null, init: FetchResponseInit = {}) {\n    const status = init.status ?? 200\n    const safeStatus = FetchResponse.isConfigurableStatusCode(status)\n      ? status\n      : 200\n    const finalBody = FetchResponse.isResponseWithBody(status) ? body : null\n\n    super(finalBody, {\n      status: safeStatus,\n      statusText: init.statusText,\n      headers: init.headers,\n    })\n\n    if (status !== safeStatus) {\n      /**\n       * @note Undici keeps an internal \"Symbol(state)\" that holds\n       * the actual value of response status. Update that in Node.js.\n       */\n      const state = getValueBySymbol<UndiciFetchInternalState>('state', this)\n\n      if (state) {\n        state.status = status\n      } else {\n        Object.defineProperty(this, 'status', {\n          value: status,\n          enumerable: true,\n          configurable: true,\n          writable: false,\n        })\n      }\n    }\n\n    FetchResponse.setUrl(init.url, this)\n  }\n}\n", "const kRawRequest = Symbol('kRawRequest')\n\n/**\n * Returns a raw request instance associated with this request.\n *\n * @example\n * interceptor.on('request', ({ request }) => {\n *   const rawRequest = getRawRequest(request)\n *\n *   if (rawRequest instanceof http.ClientRequest) {\n *     console.log(rawRequest.rawHeaders)\n *   }\n * })\n */\nexport function getRawRequest(request: Request): unknown | undefined {\n  return Reflect.get(request, kRawRequest)\n}\n\nexport function setRawRequest(request: Request, rawRequest: unknown): void {\n  Reflect.set(request, kRawRequest, rawRequest)\n}\n", "var __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/index.ts\nimport { isNodeProcess } from \"is-node-process\";\nimport { format } from \"outvariant\";\n\n// src/colors.ts\nvar colors_exports = {};\n__export(colors_exports, {\n  blue: () => blue,\n  gray: () => gray,\n  green: () => green,\n  red: () => red,\n  yellow: () => yellow\n});\nfunction yellow(text) {\n  return `\\x1B[33m${text}\\x1B[0m`;\n}\nfunction blue(text) {\n  return `\\x1B[34m${text}\\x1B[0m`;\n}\nfunction gray(text) {\n  return `\\x1B[90m${text}\\x1B[0m`;\n}\nfunction red(text) {\n  return `\\x1B[31m${text}\\x1B[0m`;\n}\nfunction green(text) {\n  return `\\x1B[32m${text}\\x1B[0m`;\n}\n\n// src/index.ts\nvar IS_NODE = isNodeProcess();\nvar Logger = class {\n  constructor(name) {\n    this.name = name;\n    this.prefix = `[${this.name}]`;\n    const LOGGER_NAME = getVariable(\"DEBUG\");\n    const LOGGER_LEVEL = getVariable(\"LOG_LEVEL\");\n    const isLoggingEnabled = LOGGER_NAME === \"1\" || LOGGER_NAME === \"true\" || typeof LOGGER_NAME !== \"undefined\" && this.name.startsWith(LOGGER_NAME);\n    if (isLoggingEnabled) {\n      this.debug = isDefinedAndNotEquals(LOGGER_LEVEL, \"debug\") ? noop : this.debug;\n      this.info = isDefinedAndNotEquals(LOGGER_LEVEL, \"info\") ? noop : this.info;\n      this.success = isDefinedAndNotEquals(LOGGER_LEVEL, \"success\") ? noop : this.success;\n      this.warning = isDefinedAndNotEquals(LOGGER_LEVEL, \"warning\") ? noop : this.warning;\n      this.error = isDefinedAndNotEquals(LOGGER_LEVEL, \"error\") ? noop : this.error;\n    } else {\n      this.info = noop;\n      this.success = noop;\n      this.warning = noop;\n      this.error = noop;\n      this.only = noop;\n    }\n  }\n  prefix;\n  extend(domain) {\n    return new Logger(`${this.name}:${domain}`);\n  }\n  /**\n   * Print a debug message.\n   * @example\n   * logger.debug('no duplicates found, creating a document...')\n   */\n  debug(message, ...positionals) {\n    this.logEntry({\n      level: \"debug\",\n      message: gray(message),\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"gray\"\n      }\n    });\n  }\n  /**\n   * Print an info message.\n   * @example\n   * logger.info('start parsing...')\n   */\n  info(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: this.prefix,\n      colors: {\n        prefix: \"blue\"\n      }\n    });\n    const performance2 = new PerformanceEntry();\n    return (message2, ...positionals2) => {\n      performance2.measure();\n      this.logEntry({\n        level: \"info\",\n        message: `${message2} ${gray(`${performance2.deltaTime}ms`)}`,\n        positionals: positionals2,\n        prefix: this.prefix,\n        colors: {\n          prefix: \"blue\"\n        }\n      });\n    };\n  }\n  /**\n   * Print a success message.\n   * @example\n   * logger.success('successfully created document')\n   */\n  success(message, ...positionals) {\n    this.logEntry({\n      level: \"info\",\n      message,\n      positionals,\n      prefix: `\\u2714 ${this.prefix}`,\n      colors: {\n        timestamp: \"green\",\n        prefix: \"green\"\n      }\n    });\n  }\n  /**\n   * Print a warning.\n   * @example\n   * logger.warning('found legacy document format')\n   */\n  warning(message, ...positionals) {\n    this.logEntry({\n      level: \"warning\",\n      message,\n      positionals,\n      prefix: `\\u26A0 ${this.prefix}`,\n      colors: {\n        timestamp: \"yellow\",\n        prefix: \"yellow\"\n      }\n    });\n  }\n  /**\n   * Print an error message.\n   * @example\n   * logger.error('something went wrong')\n   */\n  error(message, ...positionals) {\n    this.logEntry({\n      level: \"error\",\n      message,\n      positionals,\n      prefix: `\\u2716 ${this.prefix}`,\n      colors: {\n        timestamp: \"red\",\n        prefix: \"red\"\n      }\n    });\n  }\n  /**\n   * Execute the given callback only when the logging is enabled.\n   * This is skipped in its entirety and has no runtime cost otherwise.\n   * This executes regardless of the log level.\n   * @example\n   * logger.only(() => {\n   *   logger.info('additional info')\n   * })\n   */\n  only(callback) {\n    callback();\n  }\n  createEntry(level, message) {\n    return {\n      timestamp: /* @__PURE__ */ new Date(),\n      level,\n      message\n    };\n  }\n  logEntry(args) {\n    const {\n      level,\n      message,\n      prefix,\n      colors: customColors,\n      positionals = []\n    } = args;\n    const entry = this.createEntry(level, message);\n    const timestampColor = customColors?.timestamp || \"gray\";\n    const prefixColor = customColors?.prefix || \"gray\";\n    const colorize = {\n      timestamp: colors_exports[timestampColor],\n      prefix: colors_exports[prefixColor]\n    };\n    const write = this.getWriter(level);\n    write(\n      [colorize.timestamp(this.formatTimestamp(entry.timestamp))].concat(prefix != null ? colorize.prefix(prefix) : []).concat(serializeInput(message)).join(\" \"),\n      ...positionals.map(serializeInput)\n    );\n  }\n  formatTimestamp(timestamp) {\n    return `${timestamp.toLocaleTimeString(\n      \"en-GB\"\n    )}:${timestamp.getMilliseconds()}`;\n  }\n  getWriter(level) {\n    switch (level) {\n      case \"debug\":\n      case \"success\":\n      case \"info\": {\n        return log;\n      }\n      case \"warning\": {\n        return warn;\n      }\n      case \"error\": {\n        return error;\n      }\n    }\n  }\n};\nvar PerformanceEntry = class {\n  startTime;\n  endTime;\n  deltaTime;\n  constructor() {\n    this.startTime = performance.now();\n  }\n  measure() {\n    this.endTime = performance.now();\n    const deltaTime = this.endTime - this.startTime;\n    this.deltaTime = deltaTime.toFixed(2);\n  }\n};\nvar noop = () => void 0;\nfunction log(message, ...positionals) {\n  if (IS_NODE) {\n    process.stdout.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.log(message, ...positionals);\n}\nfunction warn(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.warn(message, ...positionals);\n}\nfunction error(message, ...positionals) {\n  if (IS_NODE) {\n    process.stderr.write(format(message, ...positionals) + \"\\n\");\n    return;\n  }\n  console.error(message, ...positionals);\n}\nfunction getVariable(variableName) {\n  if (IS_NODE) {\n    return process.env[variableName];\n  }\n  return globalThis[variableName]?.toString();\n}\nfunction isDefinedAndNotEquals(value, expected) {\n  return value !== void 0 && value !== expected;\n}\nfunction serializeInput(message) {\n  if (typeof message === \"undefined\") {\n    return \"undefined\";\n  }\n  if (message === null) {\n    return \"null\";\n  }\n  if (typeof message === \"string\") {\n    return message;\n  }\n  if (typeof message === \"object\") {\n    return JSON.stringify(message);\n  }\n  return message.toString();\n}\nexport {\n  Logger\n};\n", "import type { Emitter } from './Emitter'\n\nexport class MemoryLeakError extends Error {\n  constructor(\n    public readonly emitter: Emitter<any>,\n    public readonly type: string | number | symbol,\n    public readonly count: number\n  ) {\n    super(\n      `Possible EventEmitter memory leak detected. ${count} ${type.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`\n    )\n    this.name = 'MaxListenersExceededWarning'\n  }\n}\n", "import { MemoryLeakError } from './MemoryLeakError'\n\nexport type EventMap = {\n  [eventName: string]: Array<unknown>\n}\n\nexport type InternalEventNames = 'newListener' | 'removeListener'\n\nexport type InternalListener<Events extends EventMap> = Listener<\n  [eventName: keyof Events, listener: Listener<Array<unknown>>]\n>\n\nexport type Listener<Data extends Array<unknown>> = (...data: Data) => void\n\n/**\n * Node.js-compatible implementation of `EventEmitter`.\n *\n * @example\n * const emitter = new Emitter<{ hello: [string] }>()\n * emitter.on('hello', (name) => console.log(name))\n * emitter.emit('hello', 'John')\n */\nexport class Emitter<Events extends EventMap> {\n  private events: Map<keyof Events, Array<Listener<any>>>\n  private maxListeners: number\n  private hasWarnedAboutPotentialMemoryLeak: boolean\n\n  static defaultMaxListeners = 10\n\n  static listenerCount<Events extends EventMap>(\n    emitter: Emitter<EventMap>,\n    eventName: keyof Events\n  ): number {\n    return emitter.listenerCount<any>(eventName)\n  }\n\n  constructor() {\n    this.events = new Map()\n    this.maxListeners = Emitter.defaultMaxListeners\n    this.hasWarnedAboutPotentialMemoryLeak = false\n  }\n\n  private _emitInternalEvent(\n    internalEventName: InternalEventNames,\n    eventName: keyof Events,\n    listener: Listener<Array<unknown>>\n  ): void {\n    this.emit(\n      internalEventName,\n      // Anything to make TypeScript happy.\n      ...([eventName, listener] as Events['newListener'] &\n        Events['removeListener'])\n    )\n  }\n\n  private _getListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Array<unknown>>> {\n    // Always return a copy of the listeners array\n    // so they are fixed at the time of the \"_getListeners\" call.\n    return Array.prototype.concat.apply([], this.events.get(eventName)) || []\n  }\n\n  private _removeListener<EventName extends keyof Events>(\n    listeners: Array<Listener<Events[EventName]>>,\n    listener: Listener<Events[EventName]>\n  ): Array<Listener<Events[EventName]>> {\n    const index = listeners.indexOf(listener)\n\n    if (index > -1) {\n      listeners.splice(index, 1)\n    }\n\n    return []\n  }\n\n  private _wrapOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): Listener<Events[EventName]> {\n    const onceListener = (...data: Events[keyof Events]) => {\n      this.removeListener(eventName, onceListener)\n\n      /**\n       * @note Return the result of the original listener.\n       * This way this wrapped preserves listeners that are async.\n       */\n      return listener.apply(this, data)\n    }\n\n    // Inherit the name of the original listener.\n    Object.defineProperty(onceListener, 'name', { value: listener.name })\n\n    return onceListener\n  }\n\n  public setMaxListeners(maxListeners: number): this {\n    this.maxListeners = maxListeners\n    return this\n  }\n\n  /**\n   * Returns the current max listener value for the `Emitter` which is\n   * either set by `emitter.setMaxListeners(n)` or defaults to\n   * `Emitter.defaultMaxListeners`.\n   */\n  public getMaxListeners(): number {\n    return this.maxListeners\n  }\n\n  /**\n   * Returns an array listing the events for which the emitter has registered listeners.\n   * The values in the array will be strings or Symbols.\n   */\n  public eventNames(): Array<keyof Events> {\n    return Array.from(this.events.keys())\n  }\n\n  /**\n   * Synchronously calls each of the listeners registered for the event named `eventName`,\n   * in the order they were registered, passing the supplied arguments to each.\n   * Returns `true` if the event has listeners, `false` otherwise.\n   *\n   * @example\n   * const emitter = new Emitter<{ hello: [string] }>()\n   * emitter.emit('hello', 'John')\n   */\n  public emit<EventName extends keyof Events>(\n    eventName: EventName,\n    ...data: Events[EventName]\n  ): boolean {\n    const listeners = this._getListeners(eventName)\n    listeners.forEach((listener) => {\n      listener.apply(this, data)\n    })\n\n    return listeners.length > 0\n  }\n\n  public addListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public addListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public addListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: InternalListener<Events> | Listener<Events[any]>\n  ): this {\n    // Emit the `newListener` event before adding the listener.\n    this._emitInternalEvent('newListener', eventName, listener)\n\n    const nextListeners = this._getListeners(eventName).concat(listener)\n    this.events.set(eventName, nextListeners)\n\n    if (\n      this.maxListeners > 0 &&\n      this.listenerCount(eventName) > this.maxListeners &&\n      !this.hasWarnedAboutPotentialMemoryLeak\n    ) {\n      this.hasWarnedAboutPotentialMemoryLeak = true\n\n      const memoryLeakWarning = new MemoryLeakError(\n        this,\n        eventName,\n        this.listenerCount(eventName)\n      )\n      console.warn(memoryLeakWarning)\n    }\n\n    return this\n  }\n\n  public on(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public on<EventName extends keyof Events>(\n    eventName: 'removeListener' | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(eventName, listener)\n  }\n\n  public once(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public once<EventName extends keyof Events>(\n    eventName: InternalEventNames | EventName,\n    listener: Listener<any>\n  ): this {\n    return this.addListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public prependListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      const nextListeners = [listener].concat(listeners)\n      this.events.set(eventName, nextListeners)\n    } else {\n      this.events.set(eventName, listeners.concat(listener))\n    }\n\n    return this\n  }\n\n  public prependOnceListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public prependOnceListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public prependOnceListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.prependListener(\n      eventName,\n      this._wrapOnceListener(eventName, listener)\n    )\n  }\n\n  public removeListener(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public removeListener<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  public removeListener(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    const listeners = this._getListeners(eventName)\n\n    if (listeners.length > 0) {\n      this._removeListener(listeners, listener)\n      this.events.set(eventName, listeners)\n\n      // Emit the `removeListener` event after removing the listener.\n      this._emitInternalEvent('removeListener', eventName, listener)\n    }\n\n    return this\n  }\n\n  public off(\n    eventName: InternalEventNames,\n    listener: InternalListener<Events>\n  ): this\n  public off<EventName extends keyof Events>(\n    eventName: EventName,\n    listener: Listener<Events[EventName]>\n  ): this\n  /**\n   * Alias for `emitter.removeListener()`.\n   *\n   * @example\n   * emitter.off('hello', listener)\n   */\n  public off(\n    eventName: InternalEventNames | keyof Events,\n    listener: Listener<any>\n  ): this {\n    return this.removeListener(eventName, listener)\n  }\n\n  public removeAllListeners(eventName?: InternalEventNames): this\n  public removeAllListeners<EventName extends keyof Events>(\n    eventName?: EventName\n  ): this\n  public removeAllListeners(\n    eventName?: InternalEventNames | keyof Events\n  ): this {\n    if (eventName) {\n      this.events.delete(eventName)\n    } else {\n      this.events.clear()\n    }\n\n    return this\n  }\n\n  public listeners(eventName: InternalEventNames): Array<Listener<any>>\n  public listeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>>\n  /**\n   * Returns a copy of the array of listeners for the event named `eventName`.\n   */\n  public listeners(eventName: InternalEventNames | keyof Events) {\n    return Array.from(this._getListeners(eventName))\n  }\n\n  public listenerCount(eventName: InternalEventNames): number\n  public listenerCount<EventName extends keyof Events>(\n    eventName: EventName\n  ): number\n  /**\n   * Returns the number of listeners listening to the event named `eventName`.\n   */\n  public listenerCount(eventName: InternalEventNames | keyof Events): number {\n    return this._getListeners(eventName).length\n  }\n\n  public rawListeners<EventName extends keyof Events>(\n    eventName: EventName\n  ): Array<Listener<Events[EventName]>> {\n    return this.listeners(eventName)\n  }\n}\n", "import { Logger } from '@open-draft/logger'\nimport { Emitter, Listener } from 'strict-event-emitter'\n\nexport type InterceptorEventMap = Record<string, any>\nexport type InterceptorSubscription = () => void\n\n/**\n * Request header name to detect when a single request\n * is being handled by nested interceptors (XHR -> ClientRequest).\n * Obscure by design to prevent collisions with user-defined headers.\n * Ideally, come up with the Interceptor-level mechanism for this.\n * @see https://github.com/mswjs/interceptors/issues/378\n */\nexport const INTERNAL_REQUEST_ID_HEADER_NAME =\n  'x-interceptors-internal-request-id'\n\nexport function getGlobalSymbol<V>(symbol: Symbol): V | undefined {\n  return (\n    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/24587\n    globalThis[symbol] || undefined\n  )\n}\n\nfunction setGlobalSymbol(symbol: Symbol, value: any): void {\n  // @ts-ignore\n  globalThis[symbol] = value\n}\n\nexport function deleteGlobalSymbol(symbol: Symbol): void {\n  // @ts-ignore\n  delete globalThis[symbol]\n}\n\nexport enum InterceptorReadyState {\n  INACTIVE = 'INACTIVE',\n  APPLYING = 'APPLYING',\n  APPLIED = 'APPLIED',\n  DISPOSING = 'DISPOSING',\n  DISPOSED = 'DISPOSED',\n}\n\nexport type ExtractEventNames<Events extends Record<string, any>> =\n  Events extends Record<infer EventName, any> ? EventName : never\n\nexport class Interceptor<Events extends InterceptorEventMap> {\n  protected emitter: Emitter<Events>\n  protected subscriptions: Array<InterceptorSubscription>\n  protected logger: Logger\n\n  public readyState: InterceptorReadyState\n\n  constructor(private readonly symbol: symbol) {\n    this.readyState = InterceptorReadyState.INACTIVE\n\n    this.emitter = new Emitter()\n    this.subscriptions = []\n    this.logger = new Logger(symbol.description!)\n\n    // Do not limit the maximum number of listeners\n    // so not to limit the maximum amount of parallel events emitted.\n    this.emitter.setMaxListeners(0)\n\n    this.logger.info('constructing the interceptor...')\n  }\n\n  /**\n   * Determine if this interceptor can be applied\n   * in the current environment.\n   */\n  protected checkEnvironment(): boolean {\n    return true\n  }\n\n  /**\n   * Apply this interceptor to the current process.\n   * Returns an already running interceptor instance if it's present.\n   */\n  public apply(): void {\n    const logger = this.logger.extend('apply')\n    logger.info('applying the interceptor...')\n\n    if (this.readyState === InterceptorReadyState.APPLIED) {\n      logger.info('intercepted already applied!')\n      return\n    }\n\n    const shouldApply = this.checkEnvironment()\n\n    if (!shouldApply) {\n      logger.info('the interceptor cannot be applied in this environment!')\n      return\n    }\n\n    this.readyState = InterceptorReadyState.APPLYING\n\n    // Whenever applying a new interceptor, check if it hasn't been applied already.\n    // This enables to apply the same interceptor multiple times, for example from a different\n    // interceptor, only proxying events but keeping the stubs in a single place.\n    const runningInstance = this.getInstance()\n\n    if (runningInstance) {\n      logger.info('found a running instance, reusing...')\n\n      // Proxy any listeners you set on this instance to the running instance.\n      this.on = (event, listener) => {\n        logger.info('proxying the \"%s\" listener', event)\n\n        // Add listeners to the running instance so they appear\n        // at the top of the event listeners list and are executed first.\n        runningInstance.emitter.addListener(event, listener)\n\n        // Ensure that once this interceptor instance is disposed,\n        // it removes all listeners it has appended to the running interceptor instance.\n        this.subscriptions.push(() => {\n          runningInstance.emitter.removeListener(event, listener)\n          logger.info('removed proxied \"%s\" listener!', event)\n        })\n\n        return this\n      }\n\n      this.readyState = InterceptorReadyState.APPLIED\n\n      return\n    }\n\n    logger.info('no running instance found, setting up a new instance...')\n\n    // Setup the interceptor.\n    this.setup()\n\n    // Store the newly applied interceptor instance globally.\n    this.setInstance()\n\n    this.readyState = InterceptorReadyState.APPLIED\n  }\n\n  /**\n   * Setup the module augments and stubs necessary for this interceptor.\n   * This method is not run if there's a running interceptor instance\n   * to prevent instantiating an interceptor multiple times.\n   */\n  protected setup(): void {}\n\n  /**\n   * Listen to the interceptor's public events.\n   */\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    const logger = this.logger.extend('on')\n\n    if (\n      this.readyState === InterceptorReadyState.DISPOSING ||\n      this.readyState === InterceptorReadyState.DISPOSED\n    ) {\n      logger.info('cannot listen to events, already disposed!')\n      return this\n    }\n\n    logger.info('adding \"%s\" event listener:', event, listener)\n\n    this.emitter.on(event, listener)\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.once(event, listener)\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    this.emitter.off(event, listener)\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName\n  ): this {\n    this.emitter.removeAllListeners(event)\n    return this\n  }\n\n  /**\n   * Disposes of any side-effects this interceptor has introduced.\n   */\n  public dispose(): void {\n    const logger = this.logger.extend('dispose')\n\n    if (this.readyState === InterceptorReadyState.DISPOSED) {\n      logger.info('cannot dispose, already disposed!')\n      return\n    }\n\n    logger.info('disposing the interceptor...')\n    this.readyState = InterceptorReadyState.DISPOSING\n\n    if (!this.getInstance()) {\n      logger.info('no interceptors running, skipping dispose...')\n      return\n    }\n\n    // Delete the global symbol as soon as possible,\n    // indicating that the interceptor is no longer running.\n    this.clearInstance()\n\n    logger.info('global symbol deleted:', getGlobalSymbol(this.symbol))\n\n    if (this.subscriptions.length > 0) {\n      logger.info('disposing of %d subscriptions...', this.subscriptions.length)\n\n      for (const dispose of this.subscriptions) {\n        dispose()\n      }\n\n      this.subscriptions = []\n\n      logger.info('disposed of all subscriptions!', this.subscriptions.length)\n    }\n\n    this.emitter.removeAllListeners()\n    logger.info('destroyed the listener!')\n\n    this.readyState = InterceptorReadyState.DISPOSED\n  }\n\n  private getInstance(): this | undefined {\n    const instance = getGlobalSymbol<this>(this.symbol)\n    this.logger.info('retrieved global instance:', instance?.constructor?.name)\n    return instance\n  }\n\n  private setInstance(): void {\n    setGlobalSymbol(this.symbol, this)\n    this.logger.info('set global instance!', this.symbol.description)\n  }\n\n  private clearInstance(): void {\n    deleteGlobalSymbol(this.symbol)\n    this.logger.info('cleared global instance!', this.symbol.description)\n  }\n}\n", "/**\n * Generate a random ID string to represent a request.\n * @example\n * createRequestId()\n * // \"f774b6c9c600f\"\n */\nexport function createRequestId(): string {\n  return Math.random().toString(16).slice(2)\n}\n", "const encoder = new TextEncoder()\n\nexport function encodeBuffer(text: string): Uint8Array {\n  return encoder.encode(text)\n}\n\nexport function decodeBuffer(buffer: ArrayBuffer, encoding?: string): string {\n  const decoder = new TextDecoder(encoding)\n  return decoder.decode(buffer)\n}\n\n/**\n * Create an `ArrayBuffer` from the given `Uint8Array`.\n * Takes the byte offset into account to produce the right buffer\n * in the case when the buffer is bigger than the data view.\n */\nexport function toArrayBuffer(array: Uint8Array): ArrayBuffer {\n  return array.buffer.slice(\n    array.byteOffset,\n    array.byteOffset + array.byteLength\n  )\n}\n", "import { EventMap, Listener } from 'strict-event-emitter'\nimport { Interceptor, ExtractEventNames } from './Interceptor'\n\nexport interface BatchInterceptorOptions<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> {\n  name: string\n  interceptors: InterceptorList\n}\n\nexport type ExtractEventMapType<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>\n> = InterceptorList extends ReadonlyArray<infer InterceptorType>\n  ? InterceptorType extends Interceptor<infer EventMap>\n    ? EventMap\n    : never\n  : never\n\n/**\n * A batch interceptor that exposes a single interface\n * to apply and operate with multiple interceptors at once.\n */\nexport class BatchInterceptor<\n  InterceptorList extends ReadonlyArray<Interceptor<any>>,\n  Events extends EventMap = ExtractEventMapType<InterceptorList>\n> extends Interceptor<Events> {\n  static symbol: symbol\n\n  private interceptors: InterceptorList\n\n  constructor(options: BatchInterceptorOptions<InterceptorList>) {\n    BatchInterceptor.symbol = Symbol(options.name)\n    super(BatchInterceptor.symbol)\n    this.interceptors = options.interceptors\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('applying all %d interceptors...', this.interceptors.length)\n\n    for (const interceptor of this.interceptors) {\n      logger.info('applying \"%s\" interceptor...', interceptor.constructor.name)\n      interceptor.apply()\n\n      logger.info('adding interceptor dispose subscription')\n      this.subscriptions.push(() => interceptor.dispose())\n    }\n  }\n\n  public on<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    // Instead of adding a listener to the batch interceptor,\n    // propagate the listener to each of the individual interceptors.\n    for (const interceptor of this.interceptors) {\n      interceptor.on(event, listener)\n    }\n\n    return this\n  }\n\n  public once<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.once(event, listener)\n    }\n\n    return this\n  }\n\n  public off<EventName extends ExtractEventNames<Events>>(\n    event: EventName,\n    listener: Listener<Events[EventName]>\n  ): this {\n    for (const interceptor of this.interceptors) {\n      interceptor.off(event, listener)\n    }\n\n    return this\n  }\n\n  public removeAllListeners<EventName extends ExtractEventNames<Events>>(\n    event?: EventName | undefined\n  ): this {\n    for (const interceptors of this.interceptors) {\n      interceptors.removeAllListeners(event)\n    }\n\n    return this\n  }\n}\n", "/**\n * Removes query parameters and hashes from a given URL.\n */\nexport function getCleanUrl(url: URL, isAbsolute: boolean = true): string {\n  return [isAbsolute && url.origin, url.pathname].filter(Boolean).join('')\n}\n", "import { FetchResponse } from '@mswjs/interceptors'\nimport type { Emitter } from 'rettime'\nimport type { SetupWorkerInternalContext } from '../glossary'\nimport { deserializeRequest } from '../../utils/deserializeRequest'\n\nexport function createResponseListener(\n  context: SetupWorkerInternalContext,\n): Emitter.ListenerType<typeof context.workerChannel, 'RESPONSE'> {\n  return (event) => {\n    const responseMessage = event.data\n    const request = deserializeRequest(responseMessage.request)\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseMessage.response.type?.includes('opaque')) {\n      return\n    }\n\n    const response =\n      responseMessage.response.status === 0\n        ? Response.error()\n        : new FetchResponse(\n            /**\n             * Responses may be streams here, but when we create a response object\n             * with null-body status codes, like 204, 205, 304 Response will\n             * throw when passed a non-null body, so ensure it's null here\n             * for those codes\n             */\n            FetchResponse.isResponseWithBody(responseMessage.response.status)\n              ? responseMessage.response.body\n              : null,\n            {\n              ...responseMessage.response,\n              /**\n               * Set response URL if it's not set already.\n               * @see https://github.com/mswjs/msw/issues/2030\n               * @see https://developer.mozilla.org/en-US/docs/Web/API/Response/url\n               */\n              url: request.url,\n            },\n          )\n\n    context.emitter.emit(\n      responseMessage.isMockedResponse ? 'response:mocked' : 'response:bypass',\n      {\n        requestId: responseMessage.request.id,\n        request,\n        response,\n      },\n    )\n  }\n}\n", "import { devUtils } from '~/core/utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n", "import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport type {\n  SetupWorkerInternalContext,\n  StartReturnType,\n  StartOptions,\n  SetupWorker,\n} from './glossary'\nimport { RequestHandler } from '~/core/handlers/RequestHandler'\nimport { DEFAULT_START_OPTIONS } from './start/utils/prepareStartHandler'\nimport { createStartHandler } from './start/createStartHandler'\nimport { devUtils } from '~/core/utils/internal/devUtils'\nimport { SetupApi } from '~/core/SetupApi'\nimport { mergeRight } from '~/core/utils/internal/mergeRight'\nimport type { LifeCycleEventsMap } from '~/core/sharedOptions'\nimport type { WebSocketHandler } from '~/core/handlers/WebSocketHandler'\nimport { webSocketInterceptor } from '~/core/ws/webSocketInterceptor'\nimport { handleWebSocketEvent } from '~/core/ws/handleWebSocketEvent'\nimport { attachWebSocketLogger } from '~/core/ws/utils/attachWebSocketLogger'\nimport { WorkerChannel } from '../utils/workerChannel'\nimport { createFallbackRequestListener } from './start/createFallbackRequestListener'\nimport { printStartMessage } from './start/utils/printStartMessage'\nimport { printStopMessage } from './stop/utils/printStopMessage'\nimport { supportsServiceWorker } from '../utils/supports'\n\nexport class SetupWorkerApi\n  extends SetupApi<LifeCycleEventsMap>\n  implements SetupWorker\n{\n  private context: SetupWorkerInternalContext\n\n  constructor(...handlers: Array<RequestHandler | WebSocketHandler>) {\n    super(...handlers)\n\n    invariant(\n      !isNodeProcess(),\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n\n    this.context = this.createWorkerContext()\n  }\n\n  private createWorkerContext(): SetupWorkerInternalContext {\n    const workerPromise = new DeferredPromise<ServiceWorker>()\n\n    return {\n      // Mocking is not considered enabled until the worker\n      // signals back the successful activation event.\n      isMockingEnabled: false,\n      startOptions: null as any,\n      workerPromise,\n      registration: undefined,\n      getRequestHandlers: () => {\n        return this.handlersController.currentHandlers()\n      },\n      emitter: this.emitter,\n      workerChannel: new WorkerChannel({\n        worker: workerPromise,\n      }),\n    }\n  }\n\n  public async start(options: StartOptions = {}): StartReturnType {\n    if ('waitUntilReady' in options) {\n      devUtils.warn(\n        'The \"waitUntilReady\" option has been deprecated. Please remove it from this \"worker.start()\" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.',\n      )\n    }\n\n    // Warn the developer on multiple \"worker.start()\" calls.\n    // While this will not affect the worker in any way,\n    // it likely indicates an issue with the developer's code.\n    if (this.context.isMockingEnabled) {\n      devUtils.warn(\n        `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n      )\n      return this.context.registration\n    }\n\n    this.context.workerStoppedAt = undefined\n\n    this.context.startOptions = mergeRight(\n      DEFAULT_START_OPTIONS,\n      options,\n    ) as SetupWorkerInternalContext['startOptions']\n\n    // Enable the WebSocket interception.\n    handleWebSocketEvent({\n      getUnhandledRequestStrategy: () => {\n        return this.context.startOptions.onUnhandledRequest\n      },\n      getHandlers: () => {\n        return this.handlersController.currentHandlers()\n      },\n      onMockedConnection: (connection) => {\n        if (!this.context.startOptions.quiet) {\n          // Attach the logger for mocked connections since\n          // those won't be visible in the browser's devtools.\n          attachWebSocketLogger(connection)\n        }\n      },\n      onPassthroughConnection() {},\n    })\n    webSocketInterceptor.apply()\n\n    this.subscriptions.push(() => {\n      webSocketInterceptor.dispose()\n    })\n\n    // Use a fallback interception algorithm in the environments\n    // where the Service Worker API isn't supported.\n    if (!supportsServiceWorker()) {\n      const fallbackInterceptor = createFallbackRequestListener(\n        this.context,\n        this.context.startOptions,\n      )\n\n      this.subscriptions.push(() => {\n        fallbackInterceptor.dispose()\n      })\n\n      this.context.isMockingEnabled = true\n\n      printStartMessage({\n        message: 'Mocking enabled (fallback mode).',\n        quiet: this.context.startOptions.quiet,\n      })\n\n      return undefined\n    }\n\n    const startHandler = createStartHandler(this.context)\n    const registration = await startHandler(this.context.startOptions, options)\n\n    this.context.isMockingEnabled = true\n\n    return registration\n  }\n\n  public stop(): void {\n    super.dispose()\n\n    if (!this.context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Notice that stopping the worker after it has already been stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    this.context.isMockingEnabled = false\n    this.context.workerStoppedAt = Date.now()\n    this.context.emitter.removeAllListeners()\n\n    if (supportsServiceWorker()) {\n      this.context.workerChannel.removeAllListeners('RESPONSE')\n      window.clearInterval(this.context.keepAliveInterval)\n    }\n\n    // Post the internal stop message on the window\n    // to let any logic know when the worker has stopped.\n    // E.g. the WebSocket client manager needs this to know\n    // when to clear its in-memory clients list.\n    window.postMessage({ type: 'msw/worker:stop' })\n\n    printStopMessage({\n      quiet: this.context.startOptions?.quiet,\n    })\n  }\n}\n\n/**\n * Sets up a requests interception in the browser with the given request handlers.\n * @param {RequestHandler[]} handlers List of request handlers.\n *\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker()` API reference}\n */\nexport function setupWorker(\n  ...handlers: Array<RequestHandler | WebSocketHandler>\n): SetupWorker {\n  return new SetupWorkerApi(...handlers)\n}\n", "export class LensList<T> {\n  #list: Array<[string, T]>\n  #lens: Map<string, Array<T>>\n\n  constructor() {\n    this.#list = []\n    this.#lens = new Map()\n  }\n\n  get [Symbol.iterator]() {\n    // Return the list's iterator so iteration is order-sensitive.\n    return this.#list[Symbol.iterator].bind(this.#list)\n  }\n\n  public entries() {\n    return this.#lens.entries()\n  }\n\n  /**\n   * Return an order-sensitive list of values by the given key.\n   */\n  public get(key: string): Array<T> {\n    return this.#lens.get(key) || []\n  }\n\n  /**\n   * Return an order-sensitive list of all values.\n   */\n  public getAll(): Array<T> {\n    return this.#list.map(([, value]) => value)\n  }\n\n  /**\n   * Append a new value to the given key.\n   */\n  public append(key: string, value: T): void {\n    this.#list.push([key, value])\n    this.#openLens(key, (list) => list.push(value))\n  }\n\n  /**\n   * Prepend a new value to the given key.\n   */\n  public prepend(key: string, value: T): void {\n    this.#list.unshift([key, value])\n    this.#openLens(key, (list) => list.unshift(value))\n  }\n\n  /**\n   * Delete the value belonging to the given key.\n   */\n  public delete(key: string, value: T): void {\n    if (this.size === 0) {\n      return\n    }\n\n    this.#list = this.#list.filter((item) => item[1] !== value)\n\n    for (const [existingKey, values] of this.#lens) {\n      if (existingKey === key && values.includes(value)) {\n        values.splice(values.indexOf(value), 1)\n      }\n    }\n  }\n\n  /**\n   * Delete all values belogning to the given key.\n   */\n  public deleteAll(key: string): void {\n    if (this.size === 0) {\n      return\n    }\n\n    this.#list = this.#list.filter((item) => item[0] !== key)\n    this.#lens.delete(key)\n  }\n\n  get size(): number {\n    return this.#list.length\n  }\n\n  public clear(): void {\n    if (this.size === 0) {\n      return\n    }\n\n    this.#list.length = 0\n    this.#lens.clear()\n  }\n\n  #openLens(key: string, setter: (target: Array<T>) => void): void {\n    setter(this.#lens.get(key) || this.#lens.set(key, []).get(key))\n  }\n}\n", "import { LensList } from './lens-list'\n\nexport type DefaultEventMap = {\n  [eventType: string]: TypedEvent<any, any>\n}\n\n/**\n * Reserved event map containing special event types like '*' for catch-all listeners.\n */\nexport type ReservedEventMap = {\n  '*': TypedEvent<any, any, '*'>\n}\n\ntype IsReservedEvent<Type extends string> = Type extends keyof ReservedEventMap\n  ? true\n  : false\n\nexport interface TypedEvent<\n  DataType = void,\n  ReturnType = void,\n  EventType extends string = string,\n> extends Omit<MessageEvent<DataType>, 'type'> {\n  type: EventType\n}\n\nconst kDefaultPrevented = Symbol('kDefaultPrevented')\nconst kPropagationStopped = Symbol('kPropagationStopped')\nconst kImmediatePropagationStopped = Symbol('kImmediatePropagationStopped')\n\nexport class TypedEvent<\n  DataType = void,\n  ReturnType = void,\n  EventType extends string = string,\n>\n  extends MessageEvent<DataType>\n  implements TypedEvent<DataType, ReturnType, EventType>\n{\n  /**\n   * @note Keep a placeholder property with the return type\n   * because the type must be set somewhere in order to be\n   * correctly associated and inferred from the event.\n   */\n  #returnType: ReturnType;\n\n  [kDefaultPrevented]: boolean;\n  [kPropagationStopped]?: Emitter<any>;\n  [kImmediatePropagationStopped]?: boolean\n\n  constructor(\n    ...args: [DataType] extends [void]\n      ? [type: EventType]\n      : [type: EventType, init: { data: DataType }]\n  ) {\n    super(args[0], args[1])\n    this[kDefaultPrevented] = false\n  }\n\n  get defaultPrevented(): boolean {\n    return this[kDefaultPrevented]\n  }\n\n  public preventDefault(): void {\n    super.preventDefault()\n    this[kDefaultPrevented] = true\n  }\n\n  public stopImmediatePropagation(): void {\n    /**\n     * @note Despite `.stopPropagation()` and `.stopImmediatePropagation()` being defined\n     * in Node.js, they do nothing. It is safe to re-define them.\n     */\n    super.stopImmediatePropagation()\n    this[kImmediatePropagationStopped] = true\n  }\n}\n\n/**\n * Brands a TypedEvent or its subclass while preserving its (narrower) type.\n */\ntype Brand<\n  Event extends TypedEvent,\n  EventType extends string,\n  Loose extends boolean = false,\n> = Loose extends true\n  ? Event extends TypedEvent<infer Data, any, any>\n    ? /**\n       * @note Omit the `ReturnType` so emit methods can accept type events\n       * where infering the return type is impossible.\n       */\n      TypedEvent<Data, any, EventType> & {\n        type: EventType\n      }\n    : never\n  : Event & { type: EventType }\n\ntype InferEventMap<Target extends Emitter<any>> =\n  Target extends Emitter<infer EventMap> ? MergedEventMap<EventMap> : never\n\n/**\n * Extracts only user-defined events, excluding reserved event types.\n */\ntype UserEventMap<EventMap extends DefaultEventMap> = Omit<\n  EventMap,\n  keyof ReservedEventMap\n>\n\n/**\n * Merges the user EventMap with the ReservedEventMap.\n * The '*' event type accepts a union of all user-defined events.\n */\ntype MergedEventMap<EventMap extends DefaultEventMap> = EventMap &\n  ReservedEventMap\n\n/**\n * Creates a union of all events in the EventMap with their literal type strings.\n */\ntype AllEvents<EventMap extends DefaultEventMap> = {\n  [K in keyof EventMap & string]: Brand<EventMap[K], K>\n}[keyof EventMap & string]\n\nexport type TypedListenerOptions = {\n  once?: boolean\n  signal?: AbortSignal\n}\n\nconst kListenerOptions = Symbol('kListenerOptions')\n\nexport namespace Emitter {\n  /**\n   * Returns an appropriate `Event` type for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ greeting: TypedEvent<string> }>()\n   * type GreetingEvent = Emitter.InferEventType<typeof emitter, 'greeting'>\n   * // TypedEvent<string>\n   */\n  export type EventType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > =\n    IsReservedEvent<EventType> extends true\n      ? AllEvents<UserEventMap<EventMap>>\n      : Brand<EventMap[EventType], EventType>\n\n  export type EventDataType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > = EventMap[EventType] extends TypedEvent<infer DataType> ? DataType : never\n\n  /**\n   * Returns the listener type for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ getTotalPrice: TypedEvent<Cart, number> }>()\n   * type Listener = Emitter.ListenerType<typeof emitter, 'getTotalPrice'>\n   * // (event: TypedEvent<Cart>) => number\n   */\n  export type ListenerType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > =\n    IsReservedEvent<EventType> extends true\n      ? (event: AllEvents<UserEventMap<EventMap>>) => void\n      : (\n          event: Emitter.EventType<Target, EventType, EventMap>,\n        ) => Emitter.ListenerReturnType<Target, EventType, EventMap> extends [\n          void,\n        ]\n          ? void\n          : Emitter.ListenerReturnType<Target, EventType, EventMap>\n\n  /**\n   * Returns the return type of the listener for the given event type.\n   *\n   * @example\n   * const emitter = new Emitter<{ getTotalPrice: TypedEvent<Cart, number> }>()\n   * type ListenerReturnType = Emitter.InferListenerReturnType<typeof emitter, 'getTotalPrice'>\n   * // number\n   */\n  export type ListenerReturnType<\n    Target extends Emitter<any>,\n    EventType extends keyof EventMap & string,\n    EventMap extends DefaultEventMap = InferEventMap<Target>,\n  > =\n    IsReservedEvent<EventType> extends true\n      ? void\n      : EventMap[EventType] extends TypedEvent<unknown, infer ReturnType>\n        ? ReturnType\n        : never\n}\n\nexport class Emitter<EventMap extends DefaultEventMap> {\n  #listeners: LensList<\n    Emitter.ListenerType<\n      typeof this,\n      keyof MergedEventMap<EventMap> & string,\n      MergedEventMap<EventMap>\n    >\n  >\n\n  constructor() {\n    this.#listeners = new LensList()\n  }\n\n  /**\n   * Adds a listener for the given event type.\n   */\n  public on<EventType extends keyof MergedEventMap<EventMap> & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<\n      typeof this,\n      EventType,\n      MergedEventMap<EventMap>\n    >,\n    options?: TypedListenerOptions,\n  ): typeof this {\n    this.#addListener(type, listener, options)\n    return this\n  }\n\n  /**\n   * Adds a one-time listener for the given event type.\n   */\n  public once<EventType extends keyof MergedEventMap<EventMap> & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<\n      typeof this,\n      EventType,\n      MergedEventMap<EventMap>\n    >,\n    options?: Omit<TypedListenerOptions, 'once'>,\n  ): typeof this {\n    return this.on(type, listener, {\n      ...(options || {}),\n      once: true,\n    })\n  }\n\n  /**\n   * Prepends a listener for the given event type.\n   */\n  public earlyOn<EventType extends keyof MergedEventMap<EventMap> & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<\n      typeof this,\n      EventType,\n      MergedEventMap<EventMap>\n    >,\n    options?: TypedListenerOptions,\n  ): typeof this {\n    this.#addListener(type, listener, options, 'prepend')\n    return this\n  }\n\n  /**\n   * Prepends a one-time listener for the given event type.\n   */\n  public earlyOnce<EventType extends keyof MergedEventMap<EventMap> & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<\n      typeof this,\n      EventType,\n      MergedEventMap<EventMap>\n    >,\n    options?: Omit<TypedListenerOptions, 'once'>,\n  ): typeof this {\n    return this.earlyOn(type, listener, {\n      ...(options || {}),\n      once: true,\n    })\n  }\n\n  /**\n   * Emits the given typed event.\n   *\n   * @returns {boolean} Returns `true` if the event had any listeners, `false` otherwise.\n   */\n  public emit<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType, true>,\n  ): boolean {\n    if (this.#listeners.size === 0) {\n      return false\n    }\n\n    /**\n     * @note Calculate matching listeners before calling them\n     * since one-time listeners will self-destruct.\n     */\n    const hasListeners = this.listenerCount(event.type) > 0\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#matchListeners(event.type)) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        proxiedEvent.revoke()\n        return false\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      this.#callListener(proxiedEvent.event, listener)\n    }\n\n    proxiedEvent.revoke()\n\n    return hasListeners\n  }\n\n  /**\n   * Emits the given typed event and returns a promise that resolves\n   * when all the listeners for that event have settled.\n   *\n   * @returns {Promise<Array<Emitter.ListenerReturnType>>} A promise that resolves\n   * with the return values of all listeners.\n   */\n  public async emitAsPromise<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType, true>,\n  ): Promise<\n    Array<Emitter.ListenerReturnType<typeof this, EventType, EventMap>>\n  > {\n    if (this.#listeners.size === 0) {\n      return []\n    }\n\n    const pendingListeners: Array<\n      Promise<Emitter.ListenerReturnType<typeof this, EventType, EventMap>>\n    > = []\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#matchListeners(event.type)) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        proxiedEvent.revoke()\n        return []\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      const listenerPromise = Promise.resolve(\n        this.#callListener(proxiedEvent.event, listener),\n      )\n\n      const returnValue = await listenerPromise\n\n      if (!this.#isTypelessListener(listener)) {\n        pendingListeners.push(returnValue)\n      }\n    }\n\n    proxiedEvent.revoke()\n\n    return Promise.allSettled(pendingListeners).then((results) => {\n      return results.map((result) =>\n        result.status === 'fulfilled' ? result.value : result.reason,\n      )\n    })\n  }\n\n  /**\n   * Emits the given event and returns a generator that yields\n   * the result of each listener in the order of their registration.\n   * This way, you stop exhausting the listeners once you get the expected value.\n   */\n  public *emitAsGenerator<EventType extends keyof EventMap & string>(\n    event: Brand<EventMap[EventType], EventType, true>,\n  ): Generator<Emitter.ListenerReturnType<typeof this, EventType, EventMap>> {\n    if (this.#listeners.size === 0) {\n      return\n    }\n\n    const proxiedEvent = this.#proxyEvent(event)\n\n    for (const listener of this.#matchListeners(event.type)) {\n      if (\n        proxiedEvent.event[kPropagationStopped] != null &&\n        proxiedEvent.event[kPropagationStopped] !== this\n      ) {\n        proxiedEvent.revoke()\n        return\n      }\n\n      if (proxiedEvent.event[kImmediatePropagationStopped]) {\n        break\n      }\n\n      const returnValue = this.#callListener(proxiedEvent.event, listener)\n\n      if (!this.#isTypelessListener(listener)) {\n        yield returnValue\n      }\n    }\n\n    proxiedEvent.revoke()\n  }\n\n  /**\n   * Removes a listener for the given event type.\n   */\n  public removeListener<\n    EventType extends keyof MergedEventMap<EventMap> & string,\n  >(\n    type: EventType,\n    listener: Emitter.ListenerType<\n      typeof this,\n      EventType,\n      MergedEventMap<EventMap>\n    >,\n  ): void {\n    this.#listeners.delete(type, listener)\n  }\n\n  /**\n   * Removes all listeners for the given event type.\n   * If no event type is provided, removes all existing listeners.\n   */\n  public removeAllListeners<\n    EventType extends keyof MergedEventMap<EventMap> & string,\n  >(type?: EventType): void {\n    if (type == null) {\n      this.#listeners.clear()\n      return\n    }\n\n    this.#listeners.deleteAll(type)\n  }\n\n  /**\n   * Returns the list of listeners for the given event type.\n   * If no even type is provided, returns all listeners.\n   */\n  public listeners<EventType extends keyof MergedEventMap<EventMap> & string>(\n    type?: EventType,\n  ): Array<\n    Emitter.ListenerType<typeof this, EventType, MergedEventMap<EventMap>>\n  > {\n    if (type == null) {\n      return this.#listeners.getAll()\n    }\n\n    return this.#listeners.get(type)\n  }\n\n  /**\n   * Returns the number of listeners for the given event type.\n   * If no even type is provided, returns the total number of listeners.\n   */\n  public listenerCount<\n    EventType extends keyof MergedEventMap<EventMap> & string,\n  >(type?: EventType): number {\n    if (type == null) {\n      return this.#listeners.size\n    }\n\n    return this.listeners(type).length\n  }\n\n  #addListener<EventType extends keyof MergedEventMap<EventMap> & string>(\n    type: EventType,\n    listener: Emitter.ListenerType<\n      typeof this,\n      EventType,\n      MergedEventMap<EventMap>\n    >,\n    options: TypedListenerOptions | undefined,\n    insertMode: 'append' | 'prepend' = 'append',\n  ): void {\n    if (insertMode === 'prepend') {\n      this.#listeners.prepend(type, listener)\n    } else {\n      this.#listeners.append(type, listener)\n    }\n\n    if (options) {\n      Object.defineProperty(listener, kListenerOptions, {\n        value: options,\n        enumerable: false,\n        writable: false,\n      })\n\n      if (options.signal) {\n        options.signal.addEventListener(\n          'abort',\n          () => {\n            this.removeListener(type, listener)\n          },\n          { once: true },\n        )\n      }\n    }\n  }\n\n  #proxyEvent<Event extends TypedEvent>(\n    event: Event,\n  ): { event: Event; revoke: () => void } {\n    const { stopPropagation } = event\n\n    event.stopPropagation = new Proxy(event.stopPropagation, {\n      apply: (target, thisArg, argArray) => {\n        event[kPropagationStopped] = this\n        return Reflect.apply(target, thisArg, argArray)\n      },\n    })\n\n    return {\n      event,\n      revoke() {\n        event.stopPropagation = stopPropagation\n      },\n    }\n  }\n\n  #callListener(\n    event: Event,\n    listener: ((event: any) => any) & {\n      [kListenerOptions]?: TypedListenerOptions\n    },\n  ) {\n    const returnValue = listener.call(this, event)\n\n    if (listener[kListenerOptions]?.once) {\n      const key = this.#isTypelessListener(listener) ? '*' : event.type\n      this.#listeners.delete(key, listener)\n    }\n\n    return returnValue\n  }\n\n  /**\n   * Return a list of all event listeners relevant for the given event type.\n   * This includes the explicit event listeners and also typeless event listeners.\n   */\n  *#matchListeners<EventType extends keyof EventMap & string>(type: EventType) {\n    for (const [key, listener] of this.#listeners) {\n      if (key === '*' || key === type) {\n        yield listener\n      }\n    }\n  }\n\n  #isTypelessListener(listener: any): boolean {\n    return this.#listeners.get('*').includes(listener)\n  }\n}\n", "import { invariant } from 'outvariant'\nimport { Emitter, TypedEvent } from 'rettime'\nimport { isObject } from '~/core/utils/internal/isObject'\nimport type { StringifiedResponse } from '../setupWorker/glossary'\nimport { supportsServiceWorker } from '../utils/supports'\n\nexport interface WorkerChannelOptions {\n  worker: Promise<ServiceWorker>\n}\n\nexport type WorkerChannelEventMap = {\n  REQUEST: WorkerEvent<IncomingWorkerRequest>\n  RESPONSE: WorkerEvent<IncomingWorkerResponse>\n  MOCKING_ENABLED: WorkerEvent<{\n    client: {\n      id: string\n      frameType: string\n    }\n  }>\n  INTEGRITY_CHECK_RESPONSE: WorkerEvent<{\n    packageVersion: string\n    checksum: string\n  }>\n  KEEPALIVE_RESPONSE: TypedEvent<never>\n}\n\n/**\n * Request representation received from the worker message event.\n */\nexport interface IncomingWorkerRequest\n  extends Omit<\n    Request,\n    | 'text'\n    | 'body'\n    | 'json'\n    | 'blob'\n    | 'arrayBuffer'\n    | 'formData'\n    | 'clone'\n    | 'signal'\n    | 'isHistoryNavigation'\n    | 'isReloadNavigation'\n  > {\n  /**\n   * Unique ID of the request generated once the request is\n   * intercepted by the \"fetch\" event in the Service Worker.\n   */\n  id: string\n  interceptedAt: number\n  body?: ArrayBuffer | null\n}\n\ntype IncomingWorkerResponse = {\n  isMockedResponse: boolean\n  request: IncomingWorkerRequest\n  response: Pick<\n    Response,\n    'type' | 'ok' | 'status' | 'statusText' | 'body' | 'headers' | 'redirected'\n  >\n}\n\nexport type WorkerEventResponse = {\n  MOCK_RESPONSE: [\n    data: StringifiedResponse,\n    transfer?: [ReadableStream<Uint8Array>],\n  ]\n  PASSTHROUGH: []\n}\n\nconst SUPPORTS_SERVICE_WORKER = supportsServiceWorker()\n\nexport class WorkerEvent<\n  DataType,\n  ReturnType = any,\n  EventType extends string = string,\n> extends TypedEvent<DataType, ReturnType, EventType> {\n  #workerEvent: MessageEvent\n\n  constructor(workerEvent: MessageEvent) {\n    const type = workerEvent.data.type as EventType\n    const data = workerEvent.data.payload as DataType\n\n    /**\n     * @note This is the only place we're mapping { type, payload }\n     * message structure of the worker. The client references the\n     * payload via `event.data`.\n     */\n    super(\n      // @ts-expect-error Troublesome `TypedEvent` extension.\n      type,\n      { data },\n    )\n    this.#workerEvent = workerEvent\n  }\n\n  get ports() {\n    return this.#workerEvent.ports\n  }\n\n  /**\n   * Reply directly to this event using its `MessagePort`.\n   */\n  public postMessage<Type extends keyof WorkerEventResponse>(\n    type: Type,\n    ...rest: WorkerEventResponse[Type]\n  ): void {\n    this.#workerEvent.ports[0].postMessage(\n      { type, data: rest[0] },\n      { transfer: rest[1] },\n    )\n  }\n}\n\n/**\n * Map of the events that can be sent to the Service Worker\n * from any execution context.\n */\ntype OutgoingWorkerEvents =\n  | 'MOCK_ACTIVATE'\n  | 'INTEGRITY_CHECK_REQUEST'\n  | 'KEEPALIVE_REQUEST'\n  | 'CLIENT_CLOSED'\n\nexport class WorkerChannel extends Emitter<WorkerChannelEventMap> {\n  constructor(protected readonly options: WorkerChannelOptions) {\n    super()\n\n    if (!SUPPORTS_SERVICE_WORKER) {\n      return\n    }\n\n    navigator.serviceWorker.addEventListener('message', async (event) => {\n      const worker = await this.options.worker\n\n      if (event.source != null && event.source !== worker) {\n        return\n      }\n\n      if (event.data && isObject(event.data) && 'type' in event.data) {\n        this.emit(new WorkerEvent<any, any, any>(event))\n      }\n    })\n  }\n\n  /**\n   * Send data to the Service Worker controlling this client.\n   * This triggers the `message` event listener on ServiceWorkerGlobalScope.\n   */\n  public postMessage(type: OutgoingWorkerEvents): void {\n    invariant(\n      SUPPORTS_SERVICE_WORKER,\n      'Failed to post message on a WorkerChannel: the Service Worker API is unavailable in this context. This is likely an issue with MSW. Please report it on GitHub: https://github.com/mswjs/msw/issues',\n    )\n\n    this.options.worker.then((worker) => {\n      worker.postMessage(type)\n    })\n  }\n}\n", "import { Emitter, EventMap } from 'strict-event-emitter'\n\n/**\n * Emits an event on the given emitter but executes\n * the listeners sequentially. This accounts for asynchronous\n * listeners (e.g. those having \"sleep\" and handling the request).\n */\nexport async function emitAsync<\n  Events extends EventMap,\n  EventName extends keyof Events\n>(\n  emitter: Emitter<Events>,\n  eventName: EventName,\n  ...data: Events[EventName]\n): Promise<void> {\n  const listeners = emitter.listeners(eventName)\n\n  if (listeners.length === 0) {\n    return\n  }\n\n  for (const listener of listeners) {\n    await listener.apply(emitter, data)\n  }\n}\n", "/**\n * Returns a boolean indicating whether the given global property\n * is defined and is configurable.\n */\nexport function hasConfigurableGlobal(propertyName: string): boolean {\n  const descriptor = Object.getOwnPropertyDescriptor(globalThis, propertyName)\n\n  // The property is not set at all.\n  if (typeof descriptor === 'undefined') {\n    return false\n  }\n\n  // The property is set to a getter that returns undefined.\n  if (\n    typeof descriptor.get === 'function' &&\n    typeof descriptor.get() === 'undefined'\n  ) {\n    return false\n  }\n\n  // The property is set to a value equal to undefined.\n  if (typeof descriptor.get === 'undefined' && descriptor.value == null) {\n    return false\n  }\n\n  if (typeof descriptor.set === 'undefined' && !descriptor.configurable) {\n    console.error(\n      `[MSW] Failed to apply interceptor: the global \\`${propertyName}\\` property is non-configurable. This is likely an issue with your environment. If you are using a framework, please open an issue about this in their repository.`\n    )\n    return false\n  }\n\n  return true\n}\n", "export type AsyncTuple<\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n> =\n  | {\n      error: ErrorType\n      data: null\n    }\n  | { error: null; data: DataType }\n\n/**\n * Gracefully handles a given Promise factory.\n * @example\n * const { error, data } = await until(() => asyncAction())\n */\nexport const until = async <\n  ErrorType extends any = Error,\n  DataType extends any = unknown,\n>(\n  promise: () => Promise<DataType>,\n): Promise<AsyncTuple<ErrorType, DataType>> => {\n  try {\n    const data = await promise().catch((error) => {\n      throw error\n    })\n    return { error: null, data }\n  } catch (error) {\n    return { error, data: null }\n  }\n}\n", "/**\n * Determines if a given value is an instance of object.\n */\nexport function isObject<T>(value: any, loose = false): value is T {\n  return loose\n    ? Object.prototype.toString.call(value).startsWith('[object ')\n    : Object.prototype.toString.call(value) === '[object Object]'\n}\n", "/**\n * A function that validates if property access is possible on an object\n * without throwing. It returns `true` if the property access is possible\n * and `false` otherwise.\n *\n * Environments like miniflare will throw on property access on certain objects\n * like Request and Response, for unimplemented properties.\n */\nexport function isPropertyAccessible<Obj extends Record<string, any>>(\n  obj: Obj,\n  key: keyof Obj\n) {\n  try {\n    obj[key]\n    return true\n  } catch {\n    return false\n  }\n}\n", "import { isObject } from './isObject'\nimport { isPropertyAccessible } from './isPropertyAccessible'\n\n/**\n * Creates a generic 500 Unhandled Exception response.\n */\nexport function createServerErrorResponse(body: unknown): Response {\n  return new Response(\n    JSON.stringify(\n      body instanceof Error\n        ? {\n            name: body.name,\n            message: body.message,\n            stack: body.stack,\n          }\n        : body\n    ),\n    {\n      status: 500,\n      statusText: 'Unhandled Exception',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    }\n  )\n}\n\nexport type ResponseError = Response & { type: 'error' }\n\n/**\n * Check if the given response is a `Response.error()`.\n *\n * @note Some environments, like Miniflare (Cloudflare) do not\n * implement the \"Response.type\" property and throw on its access.\n * Safely check if we can access \"type\" on \"Response\" before continuing.\n * @see https://github.com/mswjs/msw/issues/1834\n */\nexport function isResponseError(response: unknown): response is ResponseError {\n  return (\n    response != null &&\n    response instanceof Response &&\n    isPropertyAccessible(response, 'type') &&\n    response.type === 'error'\n  )\n}\n\n/**\n * Check if the given value is a `Response` or a Response-like object.\n * This is different from `value instanceof Response` because it supports\n * custom `Response` constructors, like the one when using Undici directly.\n */\nexport function isResponseLike(value: unknown): value is Response {\n  return (\n    isObject<Record<string, any>>(value, true) &&\n    isPropertyAccessible(value, 'status') &&\n    isPropertyAccessible(value, 'statusText') &&\n    isPropertyAccessible(value, 'bodyUsed')\n  )\n}\n", "export function isNodeLikeError(\n  error: unknown\n): error is NodeJS.ErrnoException {\n  if (error == null) {\n    return false\n  }\n\n  if (!(error instanceof Error)) {\n    return false\n  }\n\n  return 'code' in error && 'errno' in error\n}\n", "import type { Emitter } from 'strict-event-emitter'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { until } from '@open-draft/until'\nimport type { HttpRequestEventMap } from '../glossary'\nimport { emitAsync } from './emitAsync'\nimport { RequestController } from '../RequestController'\nimport {\n  createServerErrorResponse,\n  isResponseError,\n  isResponseLike,\n} from './responseUtils'\nimport { InterceptorError } from '../InterceptorError'\nimport { isNodeLikeError } from './isNodeLikeError'\nimport { isObject } from './isObject'\n\ninterface HandleRequestOptions {\n  requestId: string\n  request: Request\n  emitter: Emitter<HttpRequestEventMap>\n  controller: RequestController\n}\n\nexport async function handleRequest(\n  options: HandleRequestOptions\n): Promise<void> {\n  const handleResponse = async (\n    response: Response | Error | Record<string, any>\n  ) => {\n    if (response instanceof Error) {\n      await options.controller.errorWith(response)\n      return true\n    }\n\n    // Handle \"Response.error()\" instances.\n    if (isResponseError(response)) {\n      await options.controller.respondWith(response)\n      return true\n    }\n\n    /**\n     * Handle normal responses or response-like objects.\n     * @note This must come before the arbitrary object check\n     * since Response instances are, in fact, objects.\n     */\n    if (isResponseLike(response)) {\n      await options.controller.respondWith(response)\n      return true\n    }\n\n    // Handle arbitrary objects provided to `.errorWith(reason)`.\n    if (isObject(response)) {\n      await options.controller.errorWith(response)\n      return true\n    }\n\n    return false\n  }\n\n  const handleResponseError = async (error: unknown): Promise<boolean> => {\n    // Forward the special interceptor error instances\n    // to the developer. These must not be handled in any way.\n    if (error instanceof InterceptorError) {\n      throw result.error\n    }\n\n    // Support mocking Node.js-like errors.\n    if (isNodeLikeError(error)) {\n      await options.controller.errorWith(error)\n      return true\n    }\n\n    // Handle thrown responses.\n    if (error instanceof Response) {\n      return await handleResponse(error)\n    }\n\n    return false\n  }\n\n  // Add the last \"request\" listener to check if the request\n  // has been handled in any way. If it hasn't, resolve the\n  // response promise with undefined.\n  // options.emitter.once('request', async ({ requestId: pendingRequestId }) => {\n  //   if (\n  //     pendingRequestId === options.requestId &&\n  //     options.controller.readyState === RequestController.PENDING\n  //   ) {\n  //     await options.controller.passthrough()\n  //   }\n  // })\n\n  const requestAbortPromise = new DeferredPromise<void, unknown>()\n\n  /**\n   * @note `signal` is not always defined in React Native.\n   */\n  if (options.request.signal) {\n    if (options.request.signal.aborted) {\n      await options.controller.errorWith(options.request.signal.reason)\n      return\n    }\n\n    options.request.signal.addEventListener(\n      'abort',\n      () => {\n        requestAbortPromise.reject(options.request.signal.reason)\n      },\n      { once: true }\n    )\n  }\n\n  const result = await until(async () => {\n    // Emit the \"request\" event and wait until all the listeners\n    // for that event are finished (e.g. async listeners awaited).\n    // By the end of this promise, the developer cannot affect the\n    // request anymore.\n    const requestListenersPromise = emitAsync(options.emitter, 'request', {\n      requestId: options.requestId,\n      request: options.request,\n      controller: options.controller,\n    })\n\n    await Promise.race([\n      // Short-circuit the request handling promise if the request gets aborted.\n      requestAbortPromise,\n      requestListenersPromise,\n      options.controller.handled,\n    ])\n  })\n\n  // Handle the request being aborted while waiting for the request listeners.\n  if (requestAbortPromise.state === 'rejected') {\n    await options.controller.errorWith(requestAbortPromise.rejectionReason)\n    return\n  }\n\n  if (result.error) {\n    // Handle the error during the request listener execution.\n    // These can be thrown responses or request errors.\n    if (await handleResponseError(result.error)) {\n      return\n    }\n\n    // If the developer has added \"unhandledException\" listeners,\n    // allow them to handle the error. They can translate it to a\n    // mocked response, network error, or forward it as-is.\n    if (options.emitter.listenerCount('unhandledException') > 0) {\n      // Create a new request controller just for the unhandled exception case.\n      // This is needed because the original controller might have been already\n      // interacted with (e.g. \"respondWith\" or \"errorWith\" called on it).\n      const unhandledExceptionController = new RequestController(\n        options.request,\n        {\n          /**\n           * @note Intentionally empty passthrough handle.\n           * This controller is created within another controller and we only need\n           * to know if `unhandledException` listeners handled the request.\n           */\n          passthrough() {},\n          async respondWith(response) {\n            await handleResponse(response)\n          },\n          async errorWith(reason) {\n            /**\n             * @note Handle the result of the unhandled controller\n             * in the same way as the original request controller.\n             * The exception here is that thrown errors within the\n             * \"unhandledException\" event do NOT result in another\n             * emit of the same event. They are forwarded as-is.\n             */\n            await options.controller.errorWith(reason)\n          },\n        }\n      )\n\n      await emitAsync(options.emitter, 'unhandledException', {\n        error: result.error,\n        request: options.request,\n        requestId: options.requestId,\n        controller: unhandledExceptionController,\n      })\n\n      // If all the \"unhandledException\" listeners have finished\n      // but have not handled the request in any way, passthrough.\n      if (\n        unhandledExceptionController.readyState !== RequestController.PENDING\n      ) {\n        return\n      }\n    }\n\n    // Otherwise, coerce unhandled exceptions to a 500 Internal Server Error response.\n    await options.controller.respondWith(\n      createServerErrorResponse(result.error)\n    )\n    return\n  }\n\n  // If the request hasn't been handled by this point, passthrough.\n  if (options.controller.readyState === RequestController.PENDING) {\n    return await options.controller.passthrough()\n  }\n\n  return options.controller.handled\n}\n", "export function createNetworkError(cause?: unknown) {\n  return Object.assign(new TypeError('Failed to fetch'), {\n    cause,\n  })\n}\n", "import { createNetworkError } from './createNetworkError'\n\nconst REQUEST_BODY_HEADERS = [\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type',\n  'content-length',\n]\n\nconst kRedirectCount = Symbol('kRedirectCount')\n\n/**\n * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/index.js#L1210\n */\nexport async function followFetchRedirect(\n  request: Request,\n  response: Response\n): Promise<Response> {\n  if (response.status !== 303 && request.body != null) {\n    return Promise.reject(createNetworkError())\n  }\n\n  const requestUrl = new URL(request.url)\n\n  let locationUrl: URL\n  try {\n    // If the location is a relative URL, use the request URL as the base URL.\n    locationUrl = new URL(response.headers.get('location')!, request.url) \n  } catch (error) {\n    return Promise.reject(createNetworkError(error))\n  }\n\n  if (\n    !(locationUrl.protocol === 'http:' || locationUrl.protocol === 'https:')\n  ) {\n    return Promise.reject(\n      createNetworkError('URL scheme must be a HTTP(S) scheme')\n    )\n  }\n\n  if (Reflect.get(request, kRedirectCount) > 20) {\n    return Promise.reject(createNetworkError('redirect count exceeded'))\n  }\n\n  Object.defineProperty(request, kRedirectCount, {\n    value: (Reflect.get(request, kRedirectCount) || 0) + 1,\n  })\n\n  if (\n    request.mode === 'cors' &&\n    (locationUrl.username || locationUrl.password) &&\n    !sameOrigin(requestUrl, locationUrl)\n  ) {\n    return Promise.reject(\n      createNetworkError('cross origin not allowed for request mode \"cors\"')\n    )\n  }\n\n  const requestInit: RequestInit = {}\n\n  if (\n    ([301, 302].includes(response.status) && request.method === 'POST') ||\n    (response.status === 303 && !['HEAD', 'GET'].includes(request.method))\n  ) {\n    requestInit.method = 'GET'\n    requestInit.body = null\n\n    REQUEST_BODY_HEADERS.forEach((headerName) => {\n      request.headers.delete(headerName)\n    })\n  }\n\n  if (!sameOrigin(requestUrl, locationUrl)) {\n    request.headers.delete('authorization')\n    request.headers.delete('proxy-authorization')\n    request.headers.delete('cookie')\n    request.headers.delete('host')\n  }\n\n  /**\n   * @note Undici \"safely\" extracts the request body.\n   * I suspect we cannot dispatch this request again\n   * since its body has been read and the stream is locked.\n   */\n\n  requestInit.headers = request.headers\n  const finalResponse = await fetch(new Request(locationUrl, requestInit))\n  Object.defineProperty(finalResponse, 'redirected', {\n    value: true,\n    configurable: true,\n  })\n\n  return finalResponse\n}\n\n/**\n * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/util.js#L761\n */\nfunction sameOrigin(left: URL, right: URL): boolean {\n  if (left.origin === right.origin && left.origin === 'null') {\n    return true\n  }\n\n  if (\n    left.protocol === right.protocol &&\n    left.hostname === right.hostname &&\n    left.port === right.port\n  ) {\n    return true\n  }\n\n  return false\n}\n", "export class BrotliDecompressionStream extends TransformStream {\n  constructor() {\n    console.warn(\n      '[Interceptors]: Brotli decompression of response streams is not supported in the browser'\n    )\n\n    super({\n      transform(chunk, controller) {\n        // Keep the stream as passthrough, it does nothing.\n        controller.enqueue(chunk)\n      },\n    })\n  }\n}\n", "// Import from an internal alias that resolves to different modules\n// depending on the environment. This way, we can keep the fetch interceptor\n// intact while using different strategies for Brotli decompression.\nimport { BrotliDecompressionStream } from 'internal:brotli-decompress'\n\nclass PipelineStream extends TransformStream {\n  constructor(\n    transformStreams: Array<TransformStream>,\n    ...strategies: Array<QueuingStrategy>\n  ) {\n    super({}, ...strategies)\n\n    const readable = [super.readable as any, ...transformStreams].reduce(\n      (readable, transform) => readable.pipeThrough(transform)\n    )\n\n    Object.defineProperty(this, 'readable', {\n      get() {\n        return readable\n      },\n    })\n  }\n}\n\nexport function parseContentEncoding(contentEncoding: string): Array<string> {\n  return contentEncoding\n    .toLowerCase()\n    .split(',')\n    .map((coding) => coding.trim())\n}\n\nfunction createDecompressionStream(\n  contentEncoding: string\n): TransformStream | null {\n  if (contentEncoding === '') {\n    return null\n  }\n\n  const codings = parseContentEncoding(contentEncoding)\n\n  if (codings.length === 0) {\n    return null\n  }\n\n  const transformers = codings.reduceRight<Array<TransformStream>>(\n    (transformers, coding) => {\n      if (coding === 'gzip' || coding === 'x-gzip') {\n        return transformers.concat(new DecompressionStream('gzip'))\n      } else if (coding === 'deflate') {\n        return transformers.concat(new DecompressionStream('deflate'))\n      } else if (coding === 'br') {\n        return transformers.concat(new BrotliDecompressionStream())\n      } else {\n        transformers.length = 0\n      }\n\n      return transformers\n    },\n    []\n  )\n\n  return new PipelineStream(transformers)\n}\n\nexport function decompressResponse(\n  response: Response\n): ReadableStream<any> | null {\n  if (response.body === null) {\n    return null\n  }\n\n  const decompressionStream = createDecompressionStream(\n    response.headers.get('content-encoding') || ''\n  )\n\n  if (!decompressionStream) {\n    return null\n  }\n\n  // Use `pipeTo` and return the decompression stream's readable\n  // instead of `pipeThrough` because that will lock the original\n  // response stream, making it unusable as the input to Response.\n  response.body.pipeTo(decompressionStream.writable)\n  return decompressionStream.readable\n}\n", "import { invariant } from 'outvariant'\nimport { until } from '@open-draft/until'\nimport { DeferredPromise } from '@open-draft/deferred-promise'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { RequestController } from '../../RequestController'\nimport { emitAsync } from '../../utils/emitAsync'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { canParseUrl } from '../../utils/canParseUrl'\nimport { createRequestId } from '../../createRequestId'\nimport { createNetworkError } from './utils/createNetworkError'\nimport { followFetchRedirect } from './utils/followRedirect'\nimport { decompressResponse } from './utils/decompression'\nimport { hasConfigurableGlobal } from '../../utils/hasConfigurableGlobal'\nimport { FetchResponse } from '../../utils/fetchUtils'\nimport { setRawRequest } from '../../getRawRequest'\nimport { isResponseError } from '../../utils/responseUtils'\n\nexport class FetchInterceptor extends Interceptor<HttpRequestEventMap> {\n  static symbol = Symbol('fetch')\n\n  constructor() {\n    super(FetchInterceptor.symbol)\n  }\n\n  protected checkEnvironment() {\n    return hasConfigurableGlobal('fetch')\n  }\n\n  protected async setup() {\n    const pureFetch = globalThis.fetch\n\n    invariant(\n      !(pureFetch as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"fetch\" module: already patched.'\n    )\n\n    globalThis.fetch = async (input, init) => {\n      const requestId = createRequestId()\n\n      /**\n       * @note Resolve potentially relative request URL\n       * against the present `location`. This is mainly\n       * for native `fetch` in JSDOM.\n       * @see https://github.com/mswjs/msw/issues/1625\n       */\n      const resolvedInput =\n        typeof input === 'string' &&\n        typeof location !== 'undefined' &&\n        !canParseUrl(input)\n          ? new URL(input, location.href)\n          : input\n\n      const request = new Request(resolvedInput, init)\n\n      /**\n       * @note Set the raw request only if a Request instance was provided to fetch.\n       */\n      if (input instanceof Request) {\n        setRawRequest(request, input)\n      }\n\n      const responsePromise = new DeferredPromise<Response>()\n\n      const controller = new RequestController(request, {\n        passthrough: async () => {\n          this.logger.info('request has not been handled, passthrough...')\n\n          /**\n           * @note Clone the request instance right before performing it.\n           * This preserves any modifications made to the intercepted request\n           * in the \"request\" listener. This also allows the user to read the\n           * request body in the \"response\" listener (otherwise \"unusable\").\n           */\n          const requestCloneForResponseEvent = request.clone()\n\n          // Perform the intercepted request as-is.\n          const { error: responseError, data: originalResponse } = await until(\n            () => pureFetch(request)\n          )\n\n          if (responseError) {\n            return responsePromise.reject(responseError)\n          }\n\n          this.logger.info('original fetch performed', originalResponse)\n\n          if (this.emitter.listenerCount('response') > 0) {\n            this.logger.info('emitting the \"response\" event...')\n\n            const responseClone = originalResponse.clone()\n            await emitAsync(this.emitter, 'response', {\n              response: responseClone,\n              isMockedResponse: false,\n              request: requestCloneForResponseEvent,\n              requestId,\n            })\n          }\n\n          // Resolve the response promise with the original response\n          // since the `fetch()` return this internal promise.\n          responsePromise.resolve(originalResponse)\n        },\n        respondWith: async (rawResponse) => {\n          // Handle mocked `Response.error()` (i.e. request errors).\n          if (isResponseError(rawResponse)) {\n            this.logger.info('request has errored!', { response: rawResponse })\n            responsePromise.reject(createNetworkError(rawResponse))\n            return\n          }\n\n          this.logger.info('received mocked response!', {\n            rawResponse,\n          })\n\n          // Decompress the mocked response body, if applicable.\n          const decompressedStream = decompressResponse(rawResponse)\n          const response =\n            decompressedStream === null\n              ? rawResponse\n              : new FetchResponse(decompressedStream, rawResponse)\n\n          FetchResponse.setUrl(request.url, response)\n\n          /**\n           * Undici's handling of following redirect responses.\n           * Treat the \"manual\" redirect mode as a regular mocked response.\n           * This way, the client can manually follow the redirect it receives.\n           * @see https://github.com/nodejs/undici/blob/a6dac3149c505b58d2e6d068b97f4dc993da55f0/lib/web/fetch/index.js#L1173\n           */\n          if (FetchResponse.isRedirectResponse(response.status)) {\n            // Reject the request promise if its `redirect` is set to `error`\n            // and it receives a mocked redirect response.\n            if (request.redirect === 'error') {\n              responsePromise.reject(createNetworkError('unexpected redirect'))\n              return\n            }\n\n            if (request.redirect === 'follow') {\n              followFetchRedirect(request, response).then(\n                (response) => {\n                  responsePromise.resolve(response)\n                },\n                (reason) => {\n                  responsePromise.reject(reason)\n                }\n              )\n              return\n            }\n          }\n\n          if (this.emitter.listenerCount('response') > 0) {\n            this.logger.info('emitting the \"response\" event...')\n\n            // Await the response listeners to finish before resolving\n            // the response promise. This ensures all your logic finishes\n            // before the interceptor resolves the pending response.\n            await emitAsync(this.emitter, 'response', {\n              // Clone the mocked response for the \"response\" event listener.\n              // This way, the listener can read the response and not lock its body\n              // for the actual fetch consumer.\n              response: response.clone(),\n              isMockedResponse: true,\n              request,\n              requestId,\n            })\n          }\n\n          responsePromise.resolve(response)\n        },\n        errorWith: (reason) => {\n          this.logger.info('request has been aborted!', { reason })\n          responsePromise.reject(reason)\n        },\n      })\n\n      this.logger.info('[%s] %s', request.method, request.url)\n      this.logger.info('awaiting for the mocked response...')\n\n      this.logger.info(\n        'emitting the \"request\" event for %s listener(s)...',\n        this.emitter.listenerCount('request')\n      )\n\n      await handleRequest({\n        request,\n        requestId,\n        emitter: this.emitter,\n        controller,\n      })\n\n      return responsePromise\n    }\n\n    Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.fetch, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.fetch = pureFetch\n\n      this.logger.info(\n        'restored native \"globalThis.fetch\"!',\n        globalThis.fetch.name\n      )\n    })\n  }\n}\n", "/**\n * Concatenate two `Uint8Array` buffers.\n */\nexport function concatArrayBuffer(\n  left: Uint8Array,\n  right: Uint8Array\n): Uint8Array {\n  const result = new Uint8Array(left.byteLength + right.byteLength)\n  result.set(left, 0)\n  result.set(right, left.byteLength)\n  return result\n}\n", "export class EventPolyfill implements Event {\n  readonly NONE = 0\n  readonly CAPTURING_PHASE = 1\n  readonly AT_TARGET = 2\n  readonly BUBBLING_PHASE = 3\n\n  public type: string = ''\n  public srcElement: EventTarget | null = null\n  public target: EventTarget | null\n  public currentTarget: EventTarget | null = null\n  public eventPhase: number = 0\n  public timeStamp: number\n  public isTrusted: boolean = true\n  public composed: boolean = false\n  public cancelable: boolean = true\n  public defaultPrevented: boolean = false\n  public bubbles: boolean = true\n  public lengthComputable: boolean = true\n  public loaded: number = 0\n  public total: number = 0\n\n  cancelBubble: boolean = false\n  returnValue: boolean = true\n\n  constructor(\n    type: string,\n    options?: { target: EventTarget; currentTarget: EventTarget }\n  ) {\n    this.type = type\n    this.target = options?.target || null\n    this.currentTarget = options?.currentTarget || null\n    this.timeStamp = Date.now()\n  }\n\n  public composedPath(): EventTarget[] {\n    return []\n  }\n\n  public initEvent(type: string, bubbles?: boolean, cancelable?: boolean) {\n    this.type = type\n    this.bubbles = !!bubbles\n    this.cancelable = !!cancelable\n  }\n\n  public preventDefault() {\n    this.defaultPrevented = true\n  }\n\n  public stopPropagation() {}\n  public stopImmediatePropagation() {}\n}\n", "import { EventPolyfill } from './EventPolyfill'\n\nexport class ProgressEventPolyfill extends EventPolyfill {\n  readonly lengthComputable: boolean\n  readonly composed: boolean\n  readonly loaded: number\n  readonly total: number\n\n  constructor(type: string, init?: ProgressEventInit) {\n    super(type)\n\n    this.lengthComputable = init?.lengthComputable || false\n    this.composed = init?.composed || false\n    this.loaded = init?.loaded || 0\n    this.total = init?.total || 0\n  }\n}\n", "import { EventPolyfill } from '../polyfills/EventPolyfill'\nimport { ProgressEventPolyfill } from '../polyfills/ProgressEventPolyfill'\n\nconst SUPPORTS_PROGRESS_EVENT = typeof ProgressEvent !== 'undefined'\n\nexport function createEvent(\n  target: XMLHttpRequest | XMLHttpRequestUpload,\n  type: string,\n  init?: ProgressEventInit\n): EventPolyfill | ProgressEvent {\n  const progressEvents = [\n    'error',\n    'progress',\n    'loadstart',\n    'loadend',\n    'load',\n    'timeout',\n    'abort',\n  ]\n\n  /**\n   * `ProgressEvent` is not supported in React Native.\n   * @see https://github.com/mswjs/interceptors/issues/40\n   */\n  const ProgressEventClass = SUPPORTS_PROGRESS_EVENT\n    ? ProgressEvent\n    : ProgressEventPolyfill\n\n  const event = progressEvents.includes(type)\n    ? new ProgressEventClass(type, {\n        lengthComputable: true,\n        loaded: init?.loaded || 0,\n        total: init?.total || 0,\n      })\n    : new EventPolyfill(type, {\n        target,\n        currentTarget: target,\n      })\n\n  return event\n}\n", "/**\n * Returns the source object of the given property on the target object\n * (the target itself, any parent in its prototype, or null).\n */\nexport function findPropertySource(\n  target: object,\n  propertyName: string | symbol\n): object | null {\n  if (!(propertyName in target)) {\n    return null\n  }\n\n  const hasProperty = Object.prototype.hasOwnProperty.call(target, propertyName)\n  if (hasProperty) {\n    return target\n  }\n\n  const prototype = Reflect.getPrototypeOf(target)\n  return prototype ? findPropertySource(prototype, propertyName) : null\n}\n", "import { findPropertySource } from './findPropertySource'\n\nexport interface ProxyOptions<Target extends Record<string, any>> {\n  constructorCall?(args: Array<unknown>, next: NextFunction<Target>): Target\n\n  methodCall?<F extends keyof Target>(\n    this: Target,\n    data: [methodName: F, args: Array<unknown>],\n    next: NextFunction<void>\n  ): void\n\n  setProperty?(\n    data: [propertyName: string | symbol, nextValue: unknown],\n    next: NextFunction<boolean>\n  ): boolean\n\n  getProperty?(\n    data: [propertyName: string | symbol, receiver: Target],\n    next: NextFunction<void>\n  ): void\n}\n\nexport type NextFunction<ReturnType> = () => ReturnType\n\nexport function createProxy<Target extends object>(\n  target: Target,\n  options: ProxyOptions<Target>\n): Target {\n  const proxy = new Proxy(target, optionsToProxyHandler(options))\n\n  return proxy\n}\n\nfunction optionsToProxyHandler<T extends Record<string, any>>(\n  options: ProxyOptions<T>\n): ProxyHandler<T> {\n  const { constructorCall, methodCall, getProperty, setProperty } = options\n  const handler: ProxyHandler<T> = {}\n\n  if (typeof constructorCall !== 'undefined') {\n    handler.construct = function (target, args, newTarget) {\n      const next = Reflect.construct.bind(null, target as any, args, newTarget)\n      return constructorCall.call(newTarget, args, next)\n    }\n  }\n\n  handler.set = function (target, propertyName, nextValue) {\n    const next = () => {\n      const propertySource = findPropertySource(target, propertyName) || target\n      const ownDescriptors = Reflect.getOwnPropertyDescriptor(\n        propertySource,\n        propertyName\n      )\n\n      // Respect any custom setters present for this property.\n      if (typeof ownDescriptors?.set !== 'undefined') {\n        ownDescriptors.set.apply(target, [nextValue])\n        return true\n      }\n\n      // Otherwise, set the property on the source.\n      return Reflect.defineProperty(propertySource, propertyName, {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value: nextValue,\n      })\n    }\n\n    if (typeof setProperty !== 'undefined') {\n      return setProperty.call(target, [propertyName, nextValue], next)\n    }\n\n    return next()\n  }\n\n  handler.get = function (target, propertyName, receiver) {\n    /**\n     * @note Using `Reflect.get()` here causes \"TypeError: Illegal invocation\".\n     */\n    const next = () => target[propertyName as any]\n\n    const value =\n      typeof getProperty !== 'undefined'\n        ? getProperty.call(target, [propertyName, receiver], next)\n        : next()\n\n    if (typeof value === 'function') {\n      return (...args: Array<any>) => {\n        const next = value.bind(target, ...args)\n\n        if (typeof methodCall !== 'undefined') {\n          return methodCall.call(target, [propertyName as any, args], next)\n        }\n\n        return next()\n      }\n    }\n\n    return value\n  }\n\n  return handler\n}\n", "export function isDomParserSupportedType(\n  type: string\n): type is DOMParserSupportedType {\n  const supportedTypes: Array<DOMParserSupportedType> = [\n    'application/xhtml+xml',\n    'application/xml',\n    'image/svg+xml',\n    'text/html',\n    'text/xml',\n  ]\n  return supportedTypes.some((supportedType) => {\n    return type.startsWith(supportedType)\n  })\n}\n", "/**\n * Parses a given string into JSON.\n * Gracefully handles invalid JSON by returning `null`.\n */\nexport function parseJson(data: string): Record<string, unknown> | null {\n  try {\n    const json = JSON.parse(data)\n    return json\n  } catch (_) {\n    return null\n  }\n}\n", "import { FetchResponse } from '../../../utils/fetchUtils'\n\n/**\n * Creates a Fetch API `Response` instance from the given\n * `XMLHttpRequest` instance and a response body.\n */\nexport function createResponse(\n  request: XMLHttpRequest,\n  body: BodyInit | null\n): Response {\n  /**\n   * Handle XMLHttpRequest responses that must have null as the\n   * response body when represented using Fetch API Response.\n   * XMLHttpRequest response will always have an empty string\n   * as the \"request.response\" in those cases, resulting in an error\n   * when constructing a Response instance.\n   * @see https://github.com/mswjs/interceptors/issues/379\n   */\n  const responseBodyOrNull = FetchResponse.isResponseWithBody(request.status)\n    ? body\n    : null\n\n  return new FetchResponse(responseBodyOrNull, {\n    url: request.responseURL,\n    status: request.status,\n    statusText: request.statusText,\n    headers: createHeadersFromXMLHttpRequestHeaders(\n      request.getAllResponseHeaders()\n    ),\n  })\n}\n\nfunction createHeadersFromXMLHttpRequestHeaders(headersString: string): Headers {\n  const headers = new Headers()\n\n  const lines = headersString.split(/[\\r\\n]+/)\n  for (const line of lines) {\n    if (line.trim() === '') {\n      continue\n    }\n\n    const [name, ...parts] = line.split(': ')\n    const value = parts.join(': ')\n\n    headers.append(name, value)\n  }\n\n  return headers\n}\n", "/**\n * Return a total byte length of the given request/response body.\n * If the `Content-Length` header is present, it will be used as the byte length.\n */\nexport async function getBodyByteLength(\n  input: Request | Response\n): Promise<number> {\n  const explicitContentLength = input.headers.get('content-length')\n\n  if (explicitContentLength != null && explicitContentLength !== '') {\n    return Number(explicitContentLength)\n  }\n\n  const buffer = await input.arrayBuffer()\n  return buffer.byteLength\n}\n", "import { invariant } from 'outvariant'\nimport { isNodeProcess } from 'is-node-process'\nimport type { Logger } from '@open-draft/logger'\nimport { concatArrayBuffer } from './utils/concatArrayBuffer'\nimport { createEvent } from './utils/createEvent'\nimport {\n  decodeBuffer,\n  encodeBuffer,\n  toArrayBuffer,\n} from '../../utils/bufferUtils'\nimport { createProxy } from '../../utils/createProxy'\nimport { isDomParserSupportedType } from './utils/isDomParserSupportedType'\nimport { parseJson } from '../../utils/parseJson'\nimport { createResponse } from './utils/createResponse'\nimport { INTERNAL_REQUEST_ID_HEADER_NAME } from '../../Interceptor'\nimport { createRequestId } from '../../createRequestId'\nimport { getBodyByteLength } from './utils/getBodyByteLength'\nimport { setRawRequest } from '../../getRawRequest'\n\nconst kIsRequestHandled = Symbol('kIsRequestHandled')\nconst IS_NODE = isNodeProcess()\nconst kFetchRequest = Symbol('kFetchRequest')\n\n/**\n * An `XMLHttpRequest` instance controller that allows us\n * to handle any given request instance (e.g. responding to it).\n */\nexport class XMLHttpRequestController {\n  public request: XMLHttpRequest\n  public requestId: string\n  public onRequest?: (\n    this: XMLHttpRequestController,\n    args: {\n      request: Request\n      requestId: string\n    }\n  ) => Promise<void>\n  public onResponse?: (\n    this: XMLHttpRequestController,\n    args: {\n      response: Response\n      isMockedResponse: boolean\n      request: Request\n      requestId: string\n    }\n  ) => void;\n\n  [kIsRequestHandled]: boolean;\n  [kFetchRequest]?: Request\n  private method: string = 'GET'\n  private url: URL = null as any\n  private requestHeaders: Headers\n  private responseBuffer: Uint8Array\n  private events: Map<keyof XMLHttpRequestEventTargetEventMap, Array<Function>>\n  private uploadEvents: Map<\n    keyof XMLHttpRequestEventTargetEventMap,\n    Array<Function>\n  >\n\n  constructor(\n    readonly initialRequest: XMLHttpRequest,\n    public logger: Logger\n  ) {\n    this[kIsRequestHandled] = false\n\n    this.events = new Map()\n    this.uploadEvents = new Map()\n    this.requestId = createRequestId()\n    this.requestHeaders = new Headers()\n    this.responseBuffer = new Uint8Array()\n\n    this.request = createProxy(initialRequest, {\n      setProperty: ([propertyName, nextValue], invoke) => {\n        switch (propertyName) {\n          case 'ontimeout': {\n            const eventName = propertyName.slice(\n              2\n            ) as keyof XMLHttpRequestEventTargetEventMap\n\n            /**\n             * @note Proxy callbacks to event listeners because JSDOM has trouble\n             * translating these properties to callbacks. It seemed to be operating\n             * on events exclusively.\n             */\n            this.request.addEventListener(eventName, nextValue as any)\n\n            return invoke()\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n      methodCall: ([methodName, args], invoke) => {\n        switch (methodName) {\n          case 'open': {\n            const [method, url] = args as [string, string | undefined]\n\n            if (typeof url === 'undefined') {\n              this.method = 'GET'\n              this.url = toAbsoluteUrl(method)\n            } else {\n              this.method = method\n              this.url = toAbsoluteUrl(url)\n            }\n\n            this.logger = this.logger.extend(`${this.method} ${this.url.href}`)\n            this.logger.info('open', this.method, this.url.href)\n\n            return invoke()\n          }\n\n          case 'addEventListener': {\n            const [eventName, listener] = args as [\n              keyof XMLHttpRequestEventTargetEventMap,\n              Function,\n            ]\n\n            this.registerEvent(eventName, listener)\n            this.logger.info('addEventListener', eventName, listener)\n\n            return invoke()\n          }\n\n          case 'setRequestHeader': {\n            const [name, value] = args as [string, string]\n            this.requestHeaders.set(name, value)\n\n            this.logger.info('setRequestHeader', name, value)\n\n            return invoke()\n          }\n\n          case 'send': {\n            const [body] = args as [\n              body?: XMLHttpRequestBodyInit | Document | null,\n            ]\n\n            this.request.addEventListener('load', () => {\n              if (typeof this.onResponse !== 'undefined') {\n                // Create a Fetch API Response representation of whichever\n                // response this XMLHttpRequest received. Note those may\n                // be either a mocked and the original response.\n                const fetchResponse = createResponse(\n                  this.request,\n                  /**\n                   * The `response` property is the right way to read\n                   * the ambiguous response body, as the request's \"responseType\" may differ.\n                   * @see https://xhr.spec.whatwg.org/#the-response-attribute\n                   */\n                  this.request.response\n                )\n\n                // Notify the consumer about the response.\n                this.onResponse.call(this, {\n                  response: fetchResponse,\n                  isMockedResponse: this[kIsRequestHandled],\n                  request: fetchRequest,\n                  requestId: this.requestId!,\n                })\n              }\n            })\n\n            const requestBody =\n              typeof body === 'string' ? encodeBuffer(body) : body\n\n            // Delegate request handling to the consumer.\n            const fetchRequest = this.toFetchApiRequest(requestBody)\n            this[kFetchRequest] = fetchRequest.clone()\n\n            /**\n             * @note Start request handling on the next tick so that the user\n             * could add event listeners for \"loadend\" before the interceptor fires it.\n             */\n            queueMicrotask(() => {\n              const onceRequestSettled =\n                this.onRequest?.call(this, {\n                  request: fetchRequest,\n                  requestId: this.requestId!,\n                }) || Promise.resolve()\n\n              onceRequestSettled.finally(() => {\n                // If the consumer didn't handle the request (called `.respondWith()`) perform it as-is.\n                if (!this[kIsRequestHandled]) {\n                  this.logger.info(\n                    'request callback settled but request has not been handled (readystate %d), performing as-is...',\n                    this.request.readyState\n                  )\n\n                  /**\n                   * @note Set the intercepted request ID on the original request in Node.js\n                   * so that if it triggers any other interceptors, they don't attempt\n                   * to process it once again.\n                   *\n                   * For instance, XMLHttpRequest is often implemented via \"http.ClientRequest\"\n                   * and we don't want for both XHR and ClientRequest interceptors to\n                   * handle the same request at the same time (e.g. emit the \"response\" event twice).\n                   */\n                  if (IS_NODE) {\n                    this.request.setRequestHeader(\n                      INTERNAL_REQUEST_ID_HEADER_NAME,\n                      this.requestId!\n                    )\n                  }\n\n                  return invoke()\n                }\n              })\n            })\n\n            break\n          }\n\n          default: {\n            return invoke()\n          }\n        }\n      },\n    })\n\n    /**\n     * Proxy the `.upload` property to gather the event listeners/callbacks.\n     */\n    define(\n      this.request,\n      'upload',\n      createProxy(this.request.upload, {\n        setProperty: ([propertyName, nextValue], invoke) => {\n          switch (propertyName) {\n            case 'onloadstart':\n            case 'onprogress':\n            case 'onaboart':\n            case 'onerror':\n            case 'onload':\n            case 'ontimeout':\n            case 'onloadend': {\n              const eventName = propertyName.slice(\n                2\n              ) as keyof XMLHttpRequestEventTargetEventMap\n\n              this.registerUploadEvent(eventName, nextValue as Function)\n            }\n          }\n\n          return invoke()\n        },\n        methodCall: ([methodName, args], invoke) => {\n          switch (methodName) {\n            case 'addEventListener': {\n              const [eventName, listener] = args as [\n                keyof XMLHttpRequestEventTargetEventMap,\n                Function,\n              ]\n              this.registerUploadEvent(eventName, listener)\n              this.logger.info('upload.addEventListener', eventName, listener)\n\n              return invoke()\n            }\n          }\n        },\n      })\n    )\n  }\n\n  private registerEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.events.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.events.set(eventName, nextEvents)\n\n    this.logger.info('registered event \"%s\"', eventName, listener)\n  }\n\n  private registerUploadEvent(\n    eventName: keyof XMLHttpRequestEventTargetEventMap,\n    listener: Function\n  ): void {\n    const prevEvents = this.uploadEvents.get(eventName) || []\n    const nextEvents = prevEvents.concat(listener)\n    this.uploadEvents.set(eventName, nextEvents)\n\n    this.logger.info('registered upload event \"%s\"', eventName, listener)\n  }\n\n  /**\n   * Responds to the current request with the given\n   * Fetch API `Response` instance.\n   */\n  public async respondWith(response: Response): Promise<void> {\n    /**\n     * @note Since `XMLHttpRequestController` delegates the handling of the responses\n     * to the \"load\" event listener that doesn't distinguish between the mocked and original\n     * responses, mark the request that had a mocked response with a corresponding symbol.\n     *\n     * Mark this request as having a mocked response immediately since\n     * calculating request/response total body length is asynchronous.\n     */\n    this[kIsRequestHandled] = true\n\n    /**\n     * Dispatch request upload events for requests with a body.\n     * @see https://github.com/mswjs/interceptors/issues/573\n     */\n    if (this[kFetchRequest]) {\n      const totalRequestBodyLength = await getBodyByteLength(\n        this[kFetchRequest]\n      )\n\n      this.trigger('loadstart', this.request.upload, {\n        loaded: 0,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('progress', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n      this.trigger('load', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n\n      this.trigger('loadend', this.request.upload, {\n        loaded: totalRequestBodyLength,\n        total: totalRequestBodyLength,\n      })\n    }\n\n    this.logger.info(\n      'responding with a mocked response: %d %s',\n      response.status,\n      response.statusText\n    )\n\n    define(this.request, 'status', response.status)\n    define(this.request, 'statusText', response.statusText)\n    define(this.request, 'responseURL', this.url.href)\n\n    this.request.getResponseHeader = new Proxy(this.request.getResponseHeader, {\n      apply: (_, __, args: [name: string]) => {\n        this.logger.info('getResponseHeader', args[0])\n\n        if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n          this.logger.info('headers not received yet, returning null')\n\n          // Headers not received yet, nothing to return.\n          return null\n        }\n\n        const headerValue = response.headers.get(args[0])\n        this.logger.info(\n          'resolved response header \"%s\" to',\n          args[0],\n          headerValue\n        )\n\n        return headerValue\n      },\n    })\n\n    this.request.getAllResponseHeaders = new Proxy(\n      this.request.getAllResponseHeaders,\n      {\n        apply: () => {\n          this.logger.info('getAllResponseHeaders')\n\n          if (this.request.readyState < this.request.HEADERS_RECEIVED) {\n            this.logger.info('headers not received yet, returning empty string')\n\n            // Headers not received yet, nothing to return.\n            return ''\n          }\n\n          const headersList = Array.from(response.headers.entries())\n          const allHeaders = headersList\n            .map(([headerName, headerValue]) => {\n              return `${headerName}: ${headerValue}`\n            })\n            .join('\\r\\n')\n\n          this.logger.info('resolved all response headers to', allHeaders)\n\n          return allHeaders\n        },\n      }\n    )\n\n    // Update the response getters to resolve against the mocked response.\n    Object.defineProperties(this.request, {\n      response: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.response,\n      },\n      responseText: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseText,\n      },\n      responseXML: {\n        enumerable: true,\n        configurable: false,\n        get: () => this.responseXML,\n      },\n    })\n\n    const totalResponseBodyLength = await getBodyByteLength(response.clone())\n\n    this.logger.info('calculated response body length', totalResponseBodyLength)\n\n    this.trigger('loadstart', this.request, {\n      loaded: 0,\n      total: totalResponseBodyLength,\n    })\n\n    this.setReadyState(this.request.HEADERS_RECEIVED)\n    this.setReadyState(this.request.LOADING)\n\n    const finalizeResponse = () => {\n      this.logger.info('finalizing the mocked response...')\n\n      this.setReadyState(this.request.DONE)\n\n      this.trigger('load', this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n\n      this.trigger('loadend', this.request, {\n        loaded: this.responseBuffer.byteLength,\n        total: totalResponseBodyLength,\n      })\n    }\n\n    if (response.body) {\n      this.logger.info('mocked response has body, streaming...')\n\n      const reader = response.body.getReader()\n\n      const readNextResponseBodyChunk = async () => {\n        const { value, done } = await reader.read()\n\n        if (done) {\n          this.logger.info('response body stream done!')\n          finalizeResponse()\n          return\n        }\n\n        if (value) {\n          this.logger.info('read response body chunk:', value)\n          this.responseBuffer = concatArrayBuffer(this.responseBuffer, value)\n\n          this.trigger('progress', this.request, {\n            loaded: this.responseBuffer.byteLength,\n            total: totalResponseBodyLength,\n          })\n        }\n\n        readNextResponseBodyChunk()\n      }\n\n      readNextResponseBodyChunk()\n    } else {\n      finalizeResponse()\n    }\n  }\n\n  private responseBufferToText(): string {\n    return decodeBuffer(this.responseBuffer)\n  }\n\n  get response(): unknown {\n    this.logger.info(\n      'getResponse (responseType: %s)',\n      this.request.responseType\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    switch (this.request.responseType) {\n      case 'json': {\n        const responseJson = parseJson(this.responseBufferToText())\n        this.logger.info('resolved response JSON', responseJson)\n\n        return responseJson\n      }\n\n      case 'arraybuffer': {\n        const arrayBuffer = toArrayBuffer(this.responseBuffer)\n        this.logger.info('resolved response ArrayBuffer', arrayBuffer)\n\n        return arrayBuffer\n      }\n\n      case 'blob': {\n        const mimeType =\n          this.request.getResponseHeader('Content-Type') || 'text/plain'\n        const responseBlob = new Blob([this.responseBufferToText()], {\n          type: mimeType,\n        })\n\n        this.logger.info(\n          'resolved response Blob (mime type: %s)',\n          responseBlob,\n          mimeType\n        )\n\n        return responseBlob\n      }\n\n      default: {\n        const responseText = this.responseBufferToText()\n        this.logger.info(\n          'resolving \"%s\" response type as text',\n          this.request.responseType,\n          responseText\n        )\n\n        return responseText\n      }\n    }\n  }\n\n  get responseText(): string {\n    /**\n     * Throw when trying to read the response body as text when the\n     * \"responseType\" doesn't expect text. This just respects the spec better.\n     * @see https://xhr.spec.whatwg.org/#the-responsetext-attribute\n     */\n    invariant(\n      this.request.responseType === '' || this.request.responseType === 'text',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (\n      this.request.readyState !== this.request.LOADING &&\n      this.request.readyState !== this.request.DONE\n    ) {\n      return ''\n    }\n\n    const responseText = this.responseBufferToText()\n    this.logger.info('getResponseText: \"%s\"', responseText)\n\n    return responseText\n  }\n\n  get responseXML(): Document | null {\n    invariant(\n      this.request.responseType === '' ||\n        this.request.responseType === 'document',\n      'InvalidStateError: The object is in invalid state.'\n    )\n\n    if (this.request.readyState !== this.request.DONE) {\n      return null\n    }\n\n    const contentType = this.request.getResponseHeader('Content-Type') || ''\n\n    if (typeof DOMParser === 'undefined') {\n      console.warn(\n        'Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly.'\n      )\n      return null\n    }\n\n    if (isDomParserSupportedType(contentType)) {\n      return new DOMParser().parseFromString(\n        this.responseBufferToText(),\n        contentType\n      )\n    }\n\n    return null\n  }\n\n  public errorWith(error?: Error): void {\n    /**\n     * @note Mark this request as handled even if it received a mock error.\n     * This prevents the controller from trying to perform this request as-is.\n     */\n    this[kIsRequestHandled] = true\n    this.logger.info('responding with an error')\n\n    this.setReadyState(this.request.DONE)\n    this.trigger('error', this.request)\n    this.trigger('loadend', this.request)\n  }\n\n  /**\n   * Transitions this request's `readyState` to the given one.\n   */\n  private setReadyState(nextReadyState: number): void {\n    this.logger.info(\n      'setReadyState: %d -> %d',\n      this.request.readyState,\n      nextReadyState\n    )\n\n    if (this.request.readyState === nextReadyState) {\n      this.logger.info('ready state identical, skipping transition...')\n      return\n    }\n\n    define(this.request, 'readyState', nextReadyState)\n\n    this.logger.info('set readyState to: %d', nextReadyState)\n\n    if (nextReadyState !== this.request.UNSENT) {\n      this.logger.info('triggering \"readystatechange\" event...')\n\n      this.trigger('readystatechange', this.request)\n    }\n  }\n\n  /**\n   * Triggers given event on the `XMLHttpRequest` instance.\n   */\n  private trigger<\n    EventName extends keyof (XMLHttpRequestEventTargetEventMap & {\n      readystatechange: ProgressEvent<XMLHttpRequestEventTarget>\n    }),\n  >(\n    eventName: EventName,\n    target: XMLHttpRequest | XMLHttpRequestUpload,\n    options?: ProgressEventInit\n  ): void {\n    const callback = (target as XMLHttpRequest)[`on${eventName}`]\n    const event = createEvent(target, eventName, options)\n\n    this.logger.info('trigger \"%s\"', eventName, options || '')\n\n    // Invoke direct callbacks.\n    if (typeof callback === 'function') {\n      this.logger.info('found a direct \"%s\" callback, calling...', eventName)\n      callback.call(target as XMLHttpRequest, event)\n    }\n\n    // Invoke event listeners.\n    const events =\n      target instanceof XMLHttpRequestUpload ? this.uploadEvents : this.events\n\n    for (const [registeredEventName, listeners] of events) {\n      if (registeredEventName === eventName) {\n        this.logger.info(\n          'found %d listener(s) for \"%s\" event, calling...',\n          listeners.length,\n          eventName\n        )\n\n        listeners.forEach((listener) => listener.call(target, event))\n      }\n    }\n  }\n\n  /**\n   * Converts this `XMLHttpRequest` instance into a Fetch API `Request` instance.\n   */\n  private toFetchApiRequest(\n    body: XMLHttpRequestBodyInit | Document | null | undefined\n  ): Request {\n    this.logger.info('converting request to a Fetch API Request...')\n\n    // If the `Document` is used as the body of this XMLHttpRequest,\n    // set its inner text as the Fetch API Request body.\n    const resolvedBody =\n      body instanceof Document ? body.documentElement.innerText : body\n\n    const fetchRequest = new Request(this.url.href, {\n      method: this.method,\n      headers: this.requestHeaders,\n      /**\n       * @see https://xhr.spec.whatwg.org/#cross-origin-credentials\n       */\n      credentials: this.request.withCredentials ? 'include' : 'same-origin',\n      body: ['GET', 'HEAD'].includes(this.method.toUpperCase())\n        ? null\n        : resolvedBody,\n    })\n\n    const proxyHeaders = createProxy(fetchRequest.headers, {\n      methodCall: ([methodName, args], invoke) => {\n        // Forward the latest state of the internal request headers\n        // because the interceptor might have modified them\n        // without responding to the request.\n        switch (methodName) {\n          case 'append':\n          case 'set': {\n            const [headerName, headerValue] = args as [string, string]\n            this.request.setRequestHeader(headerName, headerValue)\n            break\n          }\n\n          case 'delete': {\n            const [headerName] = args as [string]\n            console.warn(\n              `XMLHttpRequest: Cannot remove a \"${headerName}\" header from the Fetch API representation of the \"${fetchRequest.method} ${fetchRequest.url}\" request. XMLHttpRequest headers cannot be removed.`\n            )\n            break\n          }\n        }\n\n        return invoke()\n      },\n    })\n    define(fetchRequest, 'headers', proxyHeaders)\n    setRawRequest(fetchRequest, this.request)\n\n    this.logger.info('converted request to a Fetch API Request!', fetchRequest)\n\n    return fetchRequest\n  }\n}\n\nfunction toAbsoluteUrl(url: string | URL): URL {\n  /**\n   * @note XMLHttpRequest interceptor may run in environments\n   * that implement XMLHttpRequest but don't implement \"location\"\n   * (for example, React Native). If that's the case, return the\n   * input URL as-is (nothing to be relative to).\n   * @see https://github.com/mswjs/msw/issues/1777\n   */\n  if (typeof location === 'undefined') {\n    return new URL(url)\n  }\n\n  return new URL(url.toString(), location.href)\n}\n\nfunction define(\n  target: object,\n  property: string | symbol,\n  value: unknown\n): void {\n  Reflect.defineProperty(target, property, {\n    // Ensure writable properties to allow redefining readonly properties.\n    writable: true,\n    enumerable: true,\n    value,\n  })\n}\n", "import type { Logger } from '@open-draft/logger'\nimport { XMLHttpRequestEmitter } from '.'\nimport { RequestController } from '../../RequestController'\nimport { XMLHttpRequestController } from './XMLHttpRequestController'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { isResponseError } from '../../utils/responseUtils'\n\nexport interface XMLHttpRequestProxyOptions {\n  emitter: XMLHttpRequestEmitter\n  logger: Logger\n}\n\n/**\n * Create a proxied `XMLHttpRequest` class.\n * The proxied class establishes spies on certain methods,\n * allowing us to intercept requests and respond to them.\n */\nexport function createXMLHttpRequestProxy({\n  emitter,\n  logger,\n}: XMLHttpRequestProxyOptions) {\n  const XMLHttpRequestProxy = new Proxy(globalThis.XMLHttpRequest, {\n    construct(target, args, newTarget) {\n      logger.info('constructed new XMLHttpRequest')\n\n      const originalRequest = Reflect.construct(\n        target,\n        args,\n        newTarget\n      ) as XMLHttpRequest\n\n      /**\n       * @note Forward prototype descriptors onto the proxied object.\n       * XMLHttpRequest is implemented in JSDOM in a way that assigns\n       * a bunch of descriptors, like \"set responseType()\" on the prototype.\n       * With this propagation, we make sure that those descriptors trigger\n       * when the user operates with the proxied request instance.\n       */\n      const prototypeDescriptors = Object.getOwnPropertyDescriptors(\n        target.prototype\n      )\n      for (const propertyName in prototypeDescriptors) {\n        Reflect.defineProperty(\n          originalRequest,\n          propertyName,\n          prototypeDescriptors[propertyName]\n        )\n      }\n\n      const xhrRequestController = new XMLHttpRequestController(\n        originalRequest,\n        logger\n      )\n\n      xhrRequestController.onRequest = async function ({ request, requestId }) {\n        const controller = new RequestController(request, {\n          passthrough: () => {\n            this.logger.info(\n              'no mocked response received, performing request as-is...'\n            )\n          },\n          respondWith: async (response) => {\n            if (isResponseError(response)) {\n              this.errorWith(new TypeError('Network error'))\n              return\n            }\n\n            await this.respondWith(response)\n          },\n          errorWith: (reason) => {\n            this.logger.info('request errored!', { error: reason })\n\n            if (reason instanceof Error) {\n              this.errorWith(reason)\n            }\n          },\n        })\n\n        this.logger.info('awaiting mocked response...')\n\n        this.logger.info(\n          'emitting the \"request\" event for %s listener(s)...',\n          emitter.listenerCount('request')\n        )\n\n        await handleRequest({\n          request,\n          requestId,\n          controller,\n          emitter,\n        })\n      }\n\n      xhrRequestController.onResponse = async function ({\n        response,\n        isMockedResponse,\n        request,\n        requestId,\n      }) {\n        this.logger.info(\n          'emitting the \"response\" event for %s listener(s)...',\n          emitter.listenerCount('response')\n        )\n\n        emitter.emit('response', {\n          response,\n          isMockedResponse,\n          request,\n          requestId,\n        })\n      }\n\n      // Return the proxied request from the controller\n      // so that the controller can react to the consumer's interactions\n      // with this request (opening/sending/etc).\n      return xhrRequestController.request\n    },\n  })\n\n  return XMLHttpRequestProxy\n}\n", "import { invariant } from 'outvariant'\nimport { Emitter } from 'strict-event-emitter'\nimport { HttpRequestEventMap, IS_PATCHED_MODULE } from '../../glossary'\nimport { Interceptor } from '../../Interceptor'\nimport { createXMLHttpRequestProxy } from './XMLHttpRequestProxy'\nimport { hasConfigurableGlobal } from '../../utils/hasConfigurableGlobal'\n\nexport type XMLHttpRequestEmitter = Emitter<HttpRequestEventMap>\n\nexport class XMLHttpRequestInterceptor extends Interceptor<HttpRequestEventMap> {\n  static interceptorSymbol = Symbol('xhr')\n\n  constructor() {\n    super(XMLHttpRequestInterceptor.interceptorSymbol)\n  }\n\n  protected checkEnvironment() {\n    return hasConfigurableGlobal('XMLHttpRequest')\n  }\n\n  protected setup() {\n    const logger = this.logger.extend('setup')\n\n    logger.info('patching \"XMLHttpRequest\" module...')\n\n    const PureXMLHttpRequest = globalThis.XMLHttpRequest\n\n    invariant(\n      !(PureXMLHttpRequest as any)[IS_PATCHED_MODULE],\n      'Failed to patch the \"XMLHttpRequest\" module: already patched.'\n    )\n\n    globalThis.XMLHttpRequest = createXMLHttpRequestProxy({\n      emitter: this.emitter,\n      logger: this.logger,\n    })\n\n    logger.info(\n      'native \"XMLHttpRequest\" module patched!',\n      globalThis.XMLHttpRequest.name\n    )\n\n    Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n      enumerable: true,\n      configurable: true,\n      value: true,\n    })\n\n    this.subscriptions.push(() => {\n      Object.defineProperty(globalThis.XMLHttpRequest, IS_PATCHED_MODULE, {\n        value: undefined,\n      })\n\n      globalThis.XMLHttpRequest = PureXMLHttpRequest\n      logger.info(\n        'native \"XMLHttpRequest\" module restored!',\n        globalThis.XMLHttpRequest.name\n      )\n    })\n  }\n}\n", "import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/XMLHttpRequest'\nimport { SetupWorkerInternalContext, StartOptions } from '../glossary'\nimport type { RequiredDeep } from '~/core/typeUtils'\nimport { handleRequest } from '~/core/utils/handleRequest'\nimport { isHandlerKind } from '~/core/utils/internal/isHandlerKind'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async ({ request, requestId, controller }) => {\n    const requestCloneForLogs = request.clone()\n\n    const response = await handleRequest(\n      request,\n      requestId,\n      context.getRequestHandlers().filter(isHandlerKind('RequestHandler')),\n      options,\n      context.emitter,\n      {\n        resolutionContext: {\n          quiet: options.quiet,\n        },\n        onMockedResponse(_, { handler, parsedResult }) {\n          if (!options.quiet) {\n            context.emitter.once('response:mocked', ({ response }) => {\n              handler.log({\n                request: requestCloneForLogs,\n                response,\n                parsedResult,\n              })\n            })\n          }\n        },\n      },\n    )\n\n    if (response) {\n      controller.respondWith(response)\n    }\n  })\n\n  interceptor.on(\n    'response',\n    ({ response, isMockedResponse, request, requestId }) => {\n      context.emitter.emit(\n        isMockedResponse ? 'response:mocked' : 'response:bypass',\n        {\n          response,\n          request,\n          requestId,\n        },\n      )\n    },\n  )\n\n  interceptor.apply()\n\n  return interceptor\n}\n", "import { devUtils } from '~/core/utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  // eslint-disable-next-line no-console\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n"],
  "mappings": "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",
  "names": ["kEmitter", "kBoundListener", "socket: WebSocket", "transport: WebSocketTransport", "kEmitter", "kBoundListener", "_a", "client: WebSocketOverride", "transport: WebSocketClassTransport", "createConnection: () => WebSocket", "socket: WebSocketOverride", "_a", "error", "error", "error", "invariant", "DeferredPromise", "_a", "error: any", "worker", "devUtils", "IS_PATCHED_MODULE: unique symbol", "InterceptorError", "request: Request", "source: RequestControllerSource", "RequestController", "symbol", "FetchResponse", "Interceptor", "symbol: symbol", "createRequestId", "BatchInterceptor", "#list", "kDefaultPrevented", "Emitter", "emitAsync", "hasConfigurableGlobal", "until", "isObject", "handleRequest", "locationUrl: URL", "requestInit: RequestInit", "readable", "FetchInterceptor", "response", "handler: ProxyHandler<T>", "next", "IS_NODE", "initialRequest: XMLHttpRequest", "logger: Logger", "XMLHttpRequestInterceptor", "isHandlerKind", "mergeRight"]
}
